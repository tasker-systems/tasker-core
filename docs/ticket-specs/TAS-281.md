# Python worker bootstrap_worker() should wrap event processing pipeline

## Problem

The Python worker's `bootstrap_worker()` only initializes the Rust FFI layer (database, messaging, orchestration client). It does **not** set up the Python-side event processing pipeline, leaving that responsibility entirely to the consuming application.

This is inconsistent with the Ruby and TypeScript workers, which both provide high-level bootstrap functions that wrap the entire lifecycle.

### Cross-Language Comparison

| Worker | Bootstrap Function | Wraps Event Pipeline? |
| -- | -- | -- |
| **Ruby** | `Bootstrap.start!` | Yes — calls `start_event_processing!` which starts `EventPoller`, `EventBridge`, `StepExecutionSubscriber` |
| **TypeScript** | `WorkerServer.start()` | Yes — calls `startEventProcessingPhase()` which creates `EventSystem` with poller + subscriber |
| **Python** | `bootstrap_worker()` | **No** — only calls `_bootstrap_worker()` FFI. App must manually wire EventPoller → EventBridge → StepExecutionSubscriber → HandlerRegistry |

### Impact

Without the event processing pipeline, the Rust worker claims steps but the Python handler never receives them. Steps get stuck at `in_progress` with 0% completion indefinitely. This was discovered when building the FastAPI example app — task creation succeeded but no handlers ever executed.

## Proposed Solution

Add a high-level `Worker` class (or extend `bootstrap_worker()`) in `workers/python/python/tasker_core/` that mirrors the Ruby/TypeScript pattern:

1. Call `bootstrap_worker()` (Rust FFI init)
2. Create `HandlerRegistry.instance()` and discover handlers from a configurable package
3. Create and start `EventBridge.instance()`
4. Create and start `StepExecutionSubscriber` wired to the bridge + registry
5. Create and start `EventPoller` wired to publish events to the bridge
6. Return a result object with `worker_id`, `stop()` method, etc.

### Reference: Current tasker-contrib Workaround

The FastAPI example app currently implements this manually in both `app/main.py` (lifespan) and `tests/conftest.py`:

```python
from tasker_core import (
    EventBridge,
    EventPoller,
    HandlerRegistry,
    StepExecutionSubscriber,
    bootstrap_worker,
    stop_worker,
)

# 1. Bootstrap the Rust worker system
result = bootstrap_worker()

# 2. Discover step handlers
registry = HandlerRegistry.instance()
count = registry.discover_handlers("app.handlers")

# 3. Start event processing pipeline
bridge = EventBridge.instance()
bridge.start()

subscriber = StepExecutionSubscriber(
    event_bridge=bridge,
    handler_registry=registry,
    worker_id=result.worker_id,
)
subscriber.start()

poller = EventPoller()
poller.on_step_event(lambda event: bridge.publish("step.execution.received", event))
poller.start()
```

### Target API

Something like:

```python
from tasker_core import Worker

# High-level bootstrap (mirrors Ruby/TypeScript)
worker = Worker.start(handler_packages=["app.handlers"])

# Or with more control:
worker = Worker.start(
    handler_packages=["app.handlers"],
    auto_discover=True,
)

# Shutdown
worker.stop()
```

The existing low-level APIs (`bootstrap_worker()`, `EventPoller`, `EventBridge`, etc.) should remain available for advanced use cases.

## Migration Notes

* The `tasker-contrib` FastAPI example currently wires the pipeline manually in both `app/main.py` and `tests/conftest.py`
* This wiring should remain in place until a new version of `tasker-py` is released with the high-level API
* After the new package version, the tasker-contrib example can be simplified to use the `Worker.start()` API

## Metadata
- URL: [https://linear.app/tasker-systems/issue/TAS-281/python-worker-bootstrap-worker-should-wrap-event-processing-pipeline](https://linear.app/tasker-systems/issue/TAS-281/python-worker-bootstrap-worker-should-wrap-event-processing-pipeline)
- Identifier: TAS-281
- Status: In Progress
- Priority: High
- Assignee: Pete Taylor
- Project: [Road to Tasker Alpha](https://linear.app/tasker-systems/project/road-to-tasker-alpha-763400a12d53). Take Tasker from a codebase easy to develop on, to a project easy to use: published packages, cross-language SDKs, consumer docs, and bootstrap tooling.
- Project milestone: Phase 0: Foundation & Cleanup
- Created: 2026-02-15T17:17:06.320Z
- Updated: 2026-02-16T00:45:29.254Z
