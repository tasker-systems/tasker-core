# TAS-294: Handler QoL — Functional/Decorator Layer for FFI Workers

## Context

Tasker's value proposition is "meet teams where they are" — but today's handler ergonomics require developers to:
1. Create a class per handler with `handler_name`, `handler_version`, `call(context)`
2. Manually fetch dependency results via `context.get_dependency_result("step_name")`
3. Wrap all return values in `StepHandlerResult.success(...)` / `self.success(...)`
4. Write try/catch boilerplate for error classification
5. Include mixins and use specialized factory methods for batch/decision patterns

This is functional but invasive — it contradicts the "minimal ceremony" promise. This ticket adds an **additive, non-breaking** functional/decorator layer that sits on top of the existing class-based pattern, significantly reducing boilerplate for the common case while preserving full power for advanced use cases.

## Design Principles

- **Non-breaking**: Existing class-based handlers continue working unchanged
- **Additive only**: New module per language, no modifications to existing base classes
- **Language-idiomatic**: Python decorators, TypeScript factory functions, Ruby block DSL
- **Auto-wrapping**: Plain return values → success, raised/thrown errors → classified failure
- **Dependency injection**: Declared deps pre-fetched from context and passed as named args
- **Full context always available**: `context` parameter always present for power users

## Before/After: Python

**Before (22 lines of handler code):**
```python
class ProcessPaymentHandler(StepHandler):
    handler_name = "process_payment"
    handler_version = "1.0.0"

    def call(self, context: StepContext) -> StepHandlerResult:
        try:
            cart = context.get_dependency_result("validate_cart")
            payment_info = context.get_input("payment_info")
            if not payment_info:
                raise PermanentError("Payment info required")
            result = charge_card(payment_info, cart["total"])
            return StepHandlerResult.success({
                "payment_id": result["id"],
                "amount": cart["total"],
            })
        except PermanentError:
            raise
        except Exception as e:
            return StepHandlerResult.failure(str(e), retryable=True)
```

**After (9 lines):**
```python
@step_handler("process_payment")
@depends_on(cart="validate_cart")
@inputs("payment_info")
async def process_payment(cart, payment_info, context):
    if not payment_info:
        raise PermanentError("Payment info required")
    result = charge_card(payment_info, cart["total"])
    return {"payment_id": result["id"], "amount": cart["total"]}
```

## Before/After: TypeScript

**Before (24 lines):**
```typescript
class ProcessPaymentHandler extends StepHandler {
  static handlerName = 'process_payment';
  async call(context: StepContext): Promise<StepHandlerResult> {
    try {
      const cart = context.getDependencyResult('validate_cart');
      const paymentInfo = context.getInput('payment_info');
      if (!paymentInfo) {
        return this.failure('Payment info required', ErrorType.VALIDATION_ERROR, false);
      }
      const result = await chargeCard(paymentInfo, cart.total);
      return this.success({ paymentId: result.id, amount: cart.total });
    } catch (error) {
      return this.failure((error as Error).message, ErrorType.HANDLER_ERROR, true);
    }
  }
}
```

**After (11 lines):**
```typescript
const ProcessPayment = defineHandler("process_payment", {
  depends: { cart: "validate_cart" },
  inputs: { paymentInfo: "payment_info" },
}, async ({ cart, paymentInfo, context }) => {
  if (!paymentInfo) {
    throw new PermanentError("Payment info required");
  }
  const result = await chargeCard(paymentInfo, cart.total);
  return { paymentId: result.id, amount: cart.total };
});
```

## Before/After: Ruby

**Before (16 lines):**
```ruby
class ProcessPaymentHandler < TaskerCore::StepHandler::Base
  def call(context)
    cart = context.get_dependency_result('validate_cart')
    payment_info = context.get_input('payment_info')
    raise TaskerCore::PermanentError.new('Payment info required') unless payment_info
    result = charge_card(payment_info, cart['total'])
    success(result: {
      payment_id: result['id'],
      amount: cart['total']
    })
  rescue TaskerCore::PermanentError
    raise
  rescue StandardError => e
    failure(message: e.message, retryable: true)
  end
end
```

**After (9 lines):**
```ruby
step_handler "process_payment",
  depends_on: { cart: "validate_cart" },
  inputs: [:payment_info] do |cart:, payment_info:, context:|

  raise TaskerCore::PermanentError.new('Payment info required') unless payment_info
  result = charge_card(payment_info, cart['total'])
  { payment_id: result['id'], amount: cart['total'] }
end
```

## Implementation Plan

### Step 1: Python Functional Module

**New file: `workers/python/python/tasker_core/step_handler/functional.py`**

Core decorators:
- `@step_handler(name, version="1.0.0")` — wraps a function as a `StepHandler` subclass
- `@depends_on(**deps)` — declares dependency step results to inject as named params
- `@inputs(*keys)` — declares task context inputs to inject as named params

Specialized decorators:
- `@decision_handler(name)` — wraps function returning `Decision.route([...])` or `Decision.skip(reason)`
- `@batch_analyzer(name, worker_template=...)` — wraps function returning `BatchConfig(total_items, batch_size)`
- `@batch_worker(name)` — wraps function with auto-injected `BatchContext`

Helper classes:
- `Decision` — simple factory with `.route(steps, **routing_context)` and `.skip(reason)`
- `BatchConfig` — dataclass with `total_items`, `batch_size`, optional `max_workers`

Auto-wrapping behavior:
- If function returns `dict` → `StepHandlerResult.success(dict)`
- If function returns `StepHandlerResult` → pass through unchanged
- If function raises `PermanentError` → `StepHandlerResult.failure(retryable=False)`
- If function raises `RetryableError` → `StepHandlerResult.failure(retryable=True)`
- If function raises any other exception → `StepHandlerResult.failure(retryable=True)` (safe default, matching existing `classify_unexpected_error` behavior)

The decorated function stores a `._handler_class` attribute (the generated `StepHandler` subclass) for registry integration. Handler registration is NOT automatic — the generated class is available for explicit registration or resolver-chain discovery via the callable name.

**Modified file: `workers/python/python/tasker_core/step_handler/__init__.py`** — add exports

**New file: `workers/python/tests/test_functional_handlers.py`** — tests

### Step 2: TypeScript Functional Module

**New file: `workers/typescript/src/handler/functional.ts`**

Factory functions (not decorators — TC39 decorators are experimental):
- `defineHandler(name, options, fn)` — returns a `StepHandler` subclass
- `defineDecisionHandler(name, options, fn)` — returns a `DecisionHandler` subclass
- `defineBatchAnalyzer(name, options, fn)` — returns a `BatchableStepHandler` subclass
- `defineBatchWorker(name, options, fn)` — returns a `BatchableStepHandler` subclass

Options interface:
```typescript
interface HandlerOptions {
  depends?: Record<string, string>;   // paramName -> stepName
  inputs?: Record<string, string>;    // paramName -> inputKey
  version?: string;
}
```

Helper types:
- `Decision` class with `.route(steps, routingContext?)` and `.skip(reason)`
- `BatchConfig` interface with `totalItems`, `batchSize`

**Modified file: `workers/typescript/src/handler/index.ts`** — add exports

**New file: `workers/typescript/src/handler/__tests__/functional.test.ts`** — tests

### Step 3: Ruby Functional Module

**New file: `workers/ruby/lib/tasker_core/step_handler/functional.rb`**

DSL methods (Ruby-idiomatic block pattern):
- `step_handler(name, depends_on: {}, inputs: [], &block)` — defines handler from block
- `decision_handler(name, depends_on: {}, inputs: [], &block)` — block returns `Decision`
- `batch_analyzer(name, worker_template:, &block)` — block returns config or cursor ranges
- `batch_worker(name, &block)` — block receives `BatchContext`

Helper classes:
- `Decision` with `.route(steps, **context)` and `.skip(reason)`
- `BatchConfig` with `total_items:`, `batch_size:`

The module is a mixin that can be `include`d or `extend`ed in any Ruby module/class.

**Modified file: `workers/ruby/lib/tasker_core/step_handler/mixins.rb`** — require functional

**New file: `workers/ruby/spec/step_handler/functional_spec.rb`** — tests

### Step 4: Export & Documentation

- Update each language's top-level exports
- Add docstrings/JSDoc with examples to all new functions
- Each new file includes module-level documentation with before/after examples

## Key Design Decisions

### Error classification default: Retryable
Unhandled errors default to retryable. This matches the existing `classify_unexpected_error` in Ruby's `base.rb:301` ("Unknown errors - assume retryable for safety") and is the safer default.

### Missing dependencies: inject None/null/nil
When a declared dependency step result is missing (step failed, didn't run, or decision skipped it), inject `None`/`null`/`nil`. The handler can check explicitly. This mirrors the current `get_dependency_result()` behavior which already returns None for missing deps.

### TypeScript: Factory functions, not decorators
TC39 decorators are stage 3 and require `experimentalDecorators` or the newer `--experimentalDecorators` flag depending on runtime. A factory function like `defineHandler()` works in all TypeScript/JavaScript runtimes without configuration.

### No auto-registration
The functional API creates handler classes but does NOT auto-register them. Registration continues through the existing resolver chain / explicit registry patterns. The generated class is available via `fn._handler_class` (Python), the return value (TypeScript), or block return (Ruby) for registration.

### Class-based API remains primary
The functional API is a convenience layer. Advanced use cases (custom capabilities, config schemas, lifecycle hooks) continue using the class-based pattern. Documentation will present both patterns with guidance on when to use each.

## Critical Files

### Python
- `workers/python/python/tasker_core/step_handler/base.py` — StepHandler ABC (wrapping target)
- `workers/python/python/tasker_core/step_handler/__init__.py` — exports to update
- `workers/python/python/tasker_core/types.py` — StepHandlerResult, StepContext, DecisionPointOutcome
- `workers/python/python/tasker_core/errors/__init__.py` — PermanentError, RetryableError hierarchy
- `workers/python/python/tasker_core/batch_processing/batchable.py` — Batchable mixin for batch wrappers

### TypeScript
- `workers/typescript/src/handler/base.ts` — StepHandler abstract class (wrapping target)
- `workers/typescript/src/handler/index.ts` — exports to update
- `workers/typescript/src/types/step-handler-result.ts` — StepHandlerResult factory
- `workers/typescript/src/types/step-context.ts` — StepContext
- `workers/typescript/src/handler/decision.ts` — DecisionHandler for decision wrapper
- `workers/typescript/src/handler/batchable.ts` — BatchableStepHandler for batch wrapper

### Ruby
- `workers/ruby/lib/tasker_core/step_handler/base.rb` — StepHandler::Base (wrapping target)
- `workers/ruby/lib/tasker_core/step_handler/mixins.rb` — mixins loader to update
- `workers/ruby/lib/tasker_core/types/step_handler_call_result.rb` — result types
- `workers/ruby/lib/tasker_core/types/step_context.rb` — StepContext
- `workers/ruby/lib/tasker_core/step_handler/decision.rb` — Decision mixin for decision wrapper

## Verification

### Unit Tests
Each language gets a test file exercising:
1. Basic `@step_handler` / `defineHandler` / `step_handler` with auto-wrapping
2. Dependency injection via `@depends_on` / `depends` / `depends_on:`
3. Input injection via `@inputs` / `inputs` / `inputs:`
4. Error auto-classification (PermanentError, RetryableError, generic exceptions)
5. Decision handler helpers (`Decision.route`, `Decision.skip`)
6. Batch analyzer/worker helpers
7. Passthrough when returning a StepHandlerResult directly (no double-wrapping)
8. Missing dependency returns None/null/nil
9. Async handler support (Python + TypeScript)

### Integration Validation
- Generated handler classes are compatible with existing HandlerRegistry
- Decorated handlers can be resolved via resolver chain
- Run existing test suites to confirm no regressions:
  - `cd workers/python && python -m pytest tests/`
  - `cd workers/typescript && bun test`
  - `cd workers/ruby && bundle exec rspec`

## Implementation Order

1. Python (reference implementation — decorators are first-class in Python)
2. TypeScript (factory functions follow naturally from Python design)
3. Ruby (block DSL adapts the same concepts to Ruby idioms)

---

# TAS-294 Phase 2: Functional Examples, Output Parity Tests, and DSL E2E Tests

## Context

The TAS-294 functional/decorator layer is complete and tested:
- Python: `@step_handler`, `@decision_handler`, `@batch_analyzer`, `@batch_worker` decorators (25 unit tests pass)
- TypeScript: `defineHandler`, `defineDecisionHandler`, `defineBatchAnalyzer`, `defineBatchWorker` factories (22 unit tests pass)
- Ruby: `step_handler`, `decision_handler`, `batch_analyzer`, `batch_worker` block DSL (24 unit tests pass)

All three compose on existing mixin logic (DecisionMixin, Batchable) rather than reimplementing.

**Next goal**: Prove the functional API produces identical outputs to the verbose class-based API by:
1. Creating functional-style mirrors of every existing example handler
2. Building test harnesses that compare outputs between verbose and DSL styles
3. Creating `_dsl` task templates and e2e tests that exercise the functional handlers end-to-end

## Pre-requisite: Commit Current Work

Before starting Phase 2, commit and push the functional layer foundation (7 new files + 4 modified files).

## Scope: Handler Categories Per Language

### Common across all 3 languages (~56 handlers each)
| Category | Handlers | Pattern | DSL API |
|----------|----------|---------|---------|
| linear_workflow | 4 | Sequential deps | `@step_handler` + `@depends_on` |
| diamond_workflow | 4 | Parallel merge | `@step_handler` + `@depends_on` |
| test_scenarios/errors | 3 | Success/error | `@step_handler` (error raising) |
| conditional_approval | 6 | Decision routing | `@decision_handler` + `@step_handler` |
| batch_processing | 3 | Cursor batching | `@batch_analyzer` + `@batch_worker` |
| checkpoint_yield | 3 | Checkpoint resume | `@batch_analyzer` + `@batch_worker` |
| domain_events | 4 | Event publishing | `@step_handler` (context for events) |
| resolver_tests | 2 | Multi-method | `@step_handler` |
| blog post_01 (ecommerce) | 5 | Mixed deps | `@step_handler` + `@depends_on` |
| blog post_02 (data pipeline) | 8 | Diamond pattern | `@step_handler` + `@depends_on` |
| blog post_03 (microservices) | 5 | Parallel merge | `@step_handler` + `@depends_on` |
| blog post_04 (team scaling) | 9 | Namespaced | `@step_handler` + `@depends_on` |

### Ruby-only extras (~19 handlers)
| Category | Handlers | Pattern |
|----------|----------|---------|
| mixed_dag_workflow | 7 | Complex DAG |
| tree_workflow | 8 | Tree fan-out |
| order_fulfillment | 4 | Sequential |

## Phase 1: Create dsl-examples handler mirrors (3 languages in parallel)

### Naming Convention
- Directory: `dsl-examples/` alongside existing `examples/`
- Handler names: Same `handler_name` but with `_dsl` suffix on the step names
  - Verbose: `handler_name = "linear_workflow.step_handlers.LinearStep1Handler"`
  - DSL: `handler_name = "linear_workflow_dsl.step_handlers.linear_step_1"`
- The DSL handler must produce **identical output data** for identical inputs — only the handler_name and internal structure differ

### Python: `workers/python/tests/handlers/dsl_examples/`

Mirror directory structure:
```
workers/python/tests/handlers/dsl_examples/
├── __init__.py                          # Aggregate all DSL handlers
├── linear_workflow_handlers.py          # 4 handlers → 4 decorated functions
├── diamond_workflow_handlers.py         # 4 handlers
├── test_scenarios_handlers.py           # 3 handlers
├── conditional_approval_handlers.py     # 6 handlers (mix of @decision_handler + @step_handler)
├── batch_processing_handlers.py         # 3 handlers (@batch_analyzer + @batch_worker + @step_handler)
├── checkpoint_yield_handlers.py         # 3 handlers
├── domain_event_handlers.py             # 4 handlers (use context for event publishing)
├── resolver_tests_handlers.py           # 2 handlers
└── blog_examples/
    ├── __init__.py
    ├── post_01_ecommerce/
    │   ├── __init__.py
    │   └── handlers.py                  # 5 handlers in one file (simpler with DSL)
    ├── post_02_data_pipeline/
    │   ├── __init__.py
    │   └── handlers.py                  # 8 handlers
    ├── post_03_microservices/
    │   ├── __init__.py
    │   └── handlers.py                  # 5 handlers
    └── post_04_team_scaling/
        ├── __init__.py
        ├── customer_success/
        │   ├── __init__.py
        │   └── handlers.py              # 5 handlers
        └── payments/
            ├── __init__.py
            └── handlers.py              # 4 handlers
```

**Key source files to reference:**
- Verbose handlers: `workers/python/tests/handlers/examples/*.py`
- Functional API: `workers/python/python/tasker_core/step_handler/functional.py`
- Registration: `workers/python/tests/handlers/examples/__init__.py` (pattern to replicate)

### TypeScript: `workers/typescript/tests/handlers/dsl_examples/`

Mirror structure:
```
workers/typescript/tests/handlers/dsl_examples/
├── index.ts                             # Aggregate + ALL_DSL_HANDLERS array
├── linear_workflow/
│   ├── index.ts
│   └── step_handlers/linear-step-handlers.ts
├── diamond_workflow/
│   ├── index.ts
│   └── step_handlers/diamond-handlers.ts
├── test_scenarios/
│   ├── index.ts
│   └── step_handlers/success-step-handler.ts
├── test_errors/
│   ├── index.ts
│   └── step_handlers/error-handlers.ts
├── conditional_approval/
│   ├── index.ts
│   └── step_handlers/approval-handlers.ts
├── batch_processing/
│   ├── index.ts
│   └── step_handlers/batch-handlers.ts
├── checkpoint_yield/
│   ├── index.ts
│   └── step_handlers/checkpoint-handlers.ts
├── domain_events/
│   ├── index.ts
│   ├── step_handlers/event-handlers.ts
│   ├── publishers/payment-event-publisher.ts    # Re-export from examples/
│   └── subscribers/logging-subscriber.ts        # Re-export from examples/
├── resolver_tests/
│   ├── index.ts
│   └── step_handlers/multi-method-handler.ts
└── blog_examples/
    ├── index.ts
    ├── post_01_ecommerce/...
    ├── post_02_data_pipeline/...
    ├── post_03_microservices/...
    └── post_04_team_scaling/...
```

**Key source files to reference:**
- Verbose handlers: `workers/typescript/tests/handlers/examples/*/step_handlers/*.ts`
- Functional API: `workers/typescript/src/handler/functional.ts`
- Registration: `workers/typescript/tests/handlers/examples/index.ts`

### Ruby: `workers/ruby/spec/handlers/dsl_examples/`

Mirror structure:
```
workers/ruby/spec/handlers/dsl_examples/
├── linear_workflow/
│   └── step_handlers/linear_step_handlers.rb      # All 4 as blocks
├── diamond_workflow/
│   └── step_handlers/diamond_handlers.rb
├── mixed_dag_workflow/
│   └── step_handlers/dag_handlers.rb              # Ruby-only
├── tree_workflow/
│   └── step_handlers/tree_handlers.rb             # Ruby-only
├── order_fulfillment/
│   └── step_handlers/fulfillment_handlers.rb      # Ruby-only
├── error_scenarios/
│   └── step_handlers/error_handlers.rb
├── conditional_approval/
│   └── step_handlers/approval_handlers.rb
├── batch_processing/
│   └── step_handlers/batch_handlers.rb
├── checkpoint_yield/
│   └── step_handlers/checkpoint_handlers.rb
├── domain_events/
│   ├── step_handlers/event_handlers.rb
│   ├── publishers/                                # Re-use from examples/
│   └── subscribers/                               # Re-use from examples/
├── resolver_tests/
│   └── step_handlers/multi_method_handler.rb
└── blog_examples/
    ├── post_01_ecommerce/step_handlers/handlers.rb
    ├── post_02_data_pipeline/step_handlers/handlers.rb
    ├── post_03_microservices/step_handlers/handlers.rb
    └── post_04_team_scaling/
        ├── customer_success/step_handlers/handlers.rb
        └── payments/step_handlers/handlers.rb
```

**Key source files to reference:**
- Verbose handlers: `workers/ruby/spec/handlers/examples/*/step_handlers/*.rb`
- Functional API: `workers/ruby/lib/tasker_core/step_handler/functional.rb`
- Auto-discovery: `workers/ruby/lib/tasker_core/test_environment.rb` (glob pattern `spec/handlers/examples/**/*_handler.rb` — need to add `dsl_examples/` pattern)

### Example Rewrite: Python linear_workflow

**Verbose (67 lines for step 1 alone):**
```python
class LinearStep1Handler(StepHandler):
    handler_name = "linear_workflow.step_handlers.LinearStep1Handler"
    handler_version = "1.0.0"
    def call(self, context: StepContext) -> StepHandlerResult:
        even_number = context.input_data.get("even_number")
        if even_number is None:
            return StepHandlerResult.failure(message="...", error_type="validation_error", retryable=False)
        if not isinstance(even_number, int) or even_number % 2 != 0:
            return StepHandlerResult.failure(message="...", error_type="validation_error", retryable=False)
        result = even_number * even_number
        return StepHandlerResult.success({"result": result, "operation": "square", ...})
```

**DSL (functionally identical output):**
```python
@step_handler("linear_workflow_dsl.step_handlers.linear_step_1")
@inputs("even_number")
def linear_step_1(even_number, context):
    if even_number is None:
        raise PermanentError("Task context must contain an even_number")
    if not isinstance(even_number, int) or even_number % 2 != 0:
        raise PermanentError(f"even_number must be an even integer, got: {even_number}")
    result = even_number * even_number
    return {"result": result, "operation": "square", "step_type": "initial",
            "input_refs": {"even_number": "task.context.even_number"}}
```

### Important Design Notes

1. **Domain event handlers**: The functional API doesn't wrap event publishing. These handlers will use `@step_handler` but still access `context` directly for `context.publish_event()` calls. This is fine — showing that DSL handlers can still use context for advanced features.

2. **Batch handlers**: `CsvAnalyzerHandler` currently extends both `StepHandler` and `Batchable` and calls `self.create_cursor_ranges()`, `self.batch_analyzer_success()`. The `@batch_analyzer` decorator already composes on Batchable, so the DSL version is simpler. However, the aggregator (`CsvResultsAggregatorHandler`) uses `self.aggregate_worker_results()` — this is a Batchable method. The DSL version should use `@step_handler` with context access to the Batchable mixin methods via the generated class.

3. **Output identity**: DSL handlers MUST return the exact same `result_data` dict as their verbose counterparts for the same inputs. The only differences should be `handler_name` (which has the `_dsl` suffix on step names).

4. **Event publishers/subscribers**: For domain_events, re-use the same publisher/subscriber classes from `examples/` — only the step handlers get rewritten in DSL style.

## Phase 2: Output Parity Test Harness (3 languages in parallel)

Create a test suite per language that:
1. Constructs identical `StepContext` objects
2. Runs both verbose and DSL handlers with the same context
3. Asserts that `result_data` outputs are identical

### Python: `workers/python/tests/test_handler_parity.py`

```python
class TestHandlerParity:
    """Verify verbose and DSL handlers produce identical outputs."""

    @pytest.mark.parametrize("verbose_cls,dsl_fn,context_factory", [
        (LinearStep1Handler, linear_step_1, make_linear_step1_context),
        (LinearStep2Handler, linear_step_2, make_linear_step2_context),
        # ... all handler pairs
    ])
    def test_output_parity(self, verbose_cls, dsl_fn, context_factory):
        ctx = context_factory()
        verbose_result = verbose_cls().call(ctx)
        dsl_handler = dsl_fn._handler_class()
        dsl_result = dsl_handler.call(ctx)
        assert verbose_result.result_data == dsl_result.result_data
        assert verbose_result.success == dsl_result.success
```

### TypeScript: `workers/typescript/tests/unit/handler/parity.test.ts`

Same pattern using `describe.each` with handler pairs.

### Ruby: `workers/ruby/spec/step_handler/parity_spec.rb`

Same pattern using RSpec `shared_examples`.

### Context Factory Helpers

Each test file needs helper functions that build realistic `StepContext` objects with:
- `input_data` matching what the orchestrator provides
- `dependency_results` with outputs from upstream steps
- `step_config` / `step_inputs` for batch handlers

These can be extracted from the existing unit test helpers in each language.

## Phase 3: DSL Task Templates and E2E Tests (3 languages in parallel)

### Task Templates: `tests/fixtures/task_templates/{python,typescript,ruby}/`

For each existing template, create a `_dsl` variant:
- `linear_workflow_handler_py.yaml` → `linear_workflow_handler_dsl_py.yaml`
- `diamond_workflow_handler_py.yaml` → `diamond_workflow_handler_dsl_py.yaml`
- etc.

Changes in each DSL template:
1. `name`: insert `_dsl` before lang suffix (e.g., `mathematical_sequence_dsl_py`)
2. `namespace_name`: insert `_dsl` before lang suffix (e.g., `linear_workflow_dsl_py`)
3. Step `name` fields: insert `_dsl` before lang suffix (e.g., `linear_step_1_dsl_py`)
4. Step `handler.callable`: point to DSL handler (e.g., `linear_workflow_dsl.step_handlers.linear_step_1`)
5. Step `dependencies`: update to reference `_dsl` step names
6. Everything else (retry, timeout, input_schema, metadata) stays identical

**Template count:**
- Python: 15 templates → 15 DSL variants
- TypeScript: 17 templates → 17 DSL variants
- Ruby: 19 templates → 19 DSL variants

### E2E Tests: `tests/e2e/{python,typescript,ruby}/`

For each existing e2e test file, create a `_dsl` variant:
- `linear_workflow_test.rs` → `linear_workflow_dsl_test.rs`
- Pattern: identical assertions but using `_dsl` namespace/template names (e.g., `linear_workflow_dsl_py`, step names `linear_step_1_dsl_py`)

Changes in each DSL e2e test:
1. Function names: append `_dsl` (e.g., `test_python_linear_workflow_standard_dsl`)
2. `create_task_request` calls: use `_dsl` namespace and template names (e.g., `linear_workflow_dsl_py`, `mathematical_sequence_dsl_py`)
3. Step name assertions: use `_dsl` step names (e.g., `linear_step_1_dsl_py`)
4. All result/completion assertions: **identical** (proving output parity at the system level)

Update `mod.rs` files to include new DSL test modules.

**E2E test count:**
- Python: 12 test files → 12 DSL variants
- TypeScript: 13 test files → 13 DSL variants
- Ruby: 11 test files → 11 DSL variants

### Handler Registration for E2E

**Python**: Update `workers/python/tests/handlers/dsl_examples/__init__.py` to export all DSL handler classes. The Python worker's handler discovery scans `StepHandler` subclasses.

**TypeScript**: Add `ALL_DSL_HANDLERS` array to `dsl_examples/index.ts`. Update the test runner to register both `ALL_EXAMPLE_HANDLERS` and `ALL_DSL_HANDLERS`.

**Ruby**: Update `workers/ruby/lib/tasker_core/test_environment.rb` to also glob `spec/handlers/dsl_examples/**/*_handler.rb` (or the functional files use a different naming convention — the DSL blocks may need explicit require).

## Implementation Order

The work is naturally parallelizable as 3 independent language tracks, each with 3 sequential phases:

```
Python Track          TypeScript Track        Ruby Track
─────────────────     ─────────────────       ─────────────────
1a. func-examples     1b. func-examples       1c. func-examples
    ↓                     ↓                       ↓
2a. parity tests      2b. parity tests        2c. parity tests
    ↓                     ↓                       ↓
3a. templates+e2e     3b. templates+e2e       3c. templates+e2e
```

Each language track should be handled by a subagent. Within each track, phases are sequential (can't write parity tests without the handlers, can't write e2e tests without templates).

## Step 0: Commit and Push Foundation

Before any Phase 2 work, commit the current working tree:

**Files to commit:**
- `workers/python/python/tasker_core/step_handler/functional.py` (new)
- `workers/python/python/tasker_core/step_handler/__init__.py` (modified)
- `workers/python/tests/test_functional_handlers.py` (new)
- `workers/typescript/src/handler/functional.ts` (new)
- `workers/typescript/src/handler/index.ts` (modified)
- `workers/typescript/tests/unit/handler/functional.test.ts` (new)
- `workers/ruby/lib/tasker_core/step_handler/functional.rb` (new)
- `workers/ruby/lib/tasker_core/step_handler/mixins.rb` (modified)
- `workers/ruby/spec/step_handler/functional_spec.rb` (new)
- `docs/ticket-specs/TAS-294.md` (new)

**Exclude:** `workers/python/python/tasker_core/CLAUDE.md` (auto-generated claude-mem, not project code)

## Verification

### Unit Tests (per language)
```bash
# Python
DATABASE_URL=postgresql://tasker:tasker@localhost/tasker_rust_test \
  uv run python -m pytest tests/test_functional_handlers.py tests/test_handler_parity.py -v

# TypeScript
cd workers/typescript && bun test tests/unit/handler/functional.test.ts tests/unit/handler/parity.test.ts

# Ruby
cd workers/ruby && bundle exec rspec spec/step_handler/functional_spec.rb spec/step_handler/parity_spec.rb
```

### E2E Tests (requires full stack running)
```bash
cargo nextest run --features test-services -E 'test(~dsl)'
```

### Full Regression (ensure no breakage)
```bash
cargo make test-rust-unit
cd workers/typescript && bun test
cd workers/ruby && bundle exec rspec spec/step_handler/ spec/handlers/
```
