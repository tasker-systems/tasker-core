# TAS-205: Standalone Example Applications

## Context

The tasker-core mdBook includes 4 blog posts that demonstrate workflow orchestration patterns using inline handler examples. TAS-205 creates 4 standalone example applications (Rails, FastAPI, Bun/Hono, Axum) in tasker-contrib that reimplement all 4 blog post workflows using **framework-native semantics** — real ORMs, real migrations, real routing, real persistence. These become the canonical code references linked from the mdBook blog posts.

**Key design principle**: Each app is a real framework application that happens to use tasker-core for workflow orchestration via FFI. The framework's web server is primary; tasker's built-in web API is disabled. Domain models live in the framework's ORM. Tasks are created via the embedded FFI client and tracked by storing `task_uuid` on domain records.

**Branch**: `jcoletaylor/tas-205-phase-42-standalone-example-applications` (off merged main in tasker-contrib)

---

## The 4 Blog Post Workflows

Each app implements ALL 4 workflows:

### 1. E-commerce Order Processing (Blog Post 1)
- **5 linear steps**: ValidateInventory → ProcessPayment → UpdateInventory → SendConfirmation → GenerateInvoice
- **Pattern**: Simple sequential pipeline
- **Domain model**: `Order` (status, items, total, task_uuid)

### 2. Data Pipeline Analytics (Blog Post 2)
- **8 steps, DAG with parallel fan-out/fan-in**: IngestData → (ValidateSchema + EnrichMetadata + DetectAnomalies) → AggregateResults → GenerateReport → NotifyStakeholders → ArchiveResults
- **Pattern**: Fan-out at step 2 (3 parallel), fan-in at step 5
- **Domain model**: `AnalyticsJob` (source, status, task_uuid)

### 3. Microservices Coordination (Blog Post 3)
- **5 steps, diamond pattern**: ValidateRequest → (FetchUserProfile + FetchOrderHistory) → MergeResults → FormatResponse
- **Pattern**: Diamond dependency (2 parallel middle steps)
- **Domain model**: `ServiceRequest` (user_id, request_type, status, task_uuid)

### 4. Team Scaling with Namespace Isolation (Blog Post 4)
- **9 steps across 2 namespaces**: Team A (ReceiveOrder → ValidateItems → CalculateShipping → ApplyDiscounts → GenerateQuote) + Team B (CheckCompliance → VerifyTaxRules → AuditLog → ComplianceReport)
- **Pattern**: Namespace isolation, parallel team execution
- **Domain model**: `ComplianceCheck` (order_ref, namespace, status, task_uuid)

---

## Shared Infrastructure

### `examples/docker-compose.yml`

One shared compose file using published GHCR images — mimics a real deployment:

```yaml
services:
  postgres:
    image: ghcr.io/tasker-systems/tasker-postgres:latest
    # Includes PGMQ extension, pre-configured
    ports: ["5432:5432"]
    environment:
      POSTGRES_USER: tasker
      POSTGRES_PASSWORD: tasker
      POSTGRES_DB: tasker

  orchestration:
    image: ghcr.io/tasker-systems/tasker-orchestration:latest
    depends_on: [postgres, dragonfly, rabbitmq]
    ports: ["8080:8080"]
    environment:
      DATABASE_URL: postgresql://tasker:tasker@postgres/tasker

  dragonfly:
    image: docker.dragonflydb.io/dragonflydb/dragonfly:latest
    ports: ["6379:6379"]

  rabbitmq:
    image: rabbitmq:3-management
    ports: ["5672:5672", "15672:15672"]
```

Each example app adds its own app-specific database (separate from tasker's) for domain models.

### `examples/shared/` — Shared Configuration

- `tasker-worker.toml` — Base worker config with `[worker.web] enabled = false` and `[worker.grpc] enabled = false`
- `task-templates/` — Reference task template YAML files for all 4 workflows (each app copies/adapts these)
- `README.md` — Setup instructions for running examples

---

## Directory Structure

```
examples/
├── docker-compose.yml              # Shared infrastructure (GHCR images)
├── shared/
│   ├── tasker-worker.toml          # Base worker config (web/grpc disabled)
│   └── README.md
├── rails-app/                      # Ruby on Rails
│   ├── .env                        # TASKER_TEMPLATE_PATH, TASKER_CONFIG_PATH, DATABASE_URL
│   ├── Gemfile
│   ├── Rakefile
│   ├── config/
│   │   ├── database.yml
│   │   ├── routes.rb
│   │   └── tasker/                 # Tasker worker config
│   │       ├── worker.toml
│   │       └── templates/          # Task template YAMLs (4 workflows)
│   ├── db/
│   │   └── migrate/               # Rails migrations for domain models
│   ├── app/
│   │   ├── models/                 # ActiveRecord models (Order, AnalyticsJob, etc.)
│   │   ├── controllers/           # API controllers
│   │   └── handlers/              # Tasker step handlers (4 workflow modules)
│   ├── spec/
│   │   └── integration/           # RSpec integration tests
│   └── README.md
├── fastapi-app/                    # Python FastAPI
│   ├── .env
│   ├── pyproject.toml
│   ├── alembic.ini
│   ├── alembic/
│   │   └── versions/              # Alembic migrations
│   ├── app/
│   │   ├── main.py                # FastAPI app + lifespan (FFI bootstrap)
│   │   ├── models.py              # SQLAlchemy models
│   │   ├── schemas.py             # Pydantic schemas
│   │   ├── routes/                # API routers (orders, analytics, etc.)
│   │   ├── handlers/              # Tasker step handlers
│   │   └── config/
│   │       └── worker.toml
│   ├── tests/
│   │   └── test_integration.py    # pytest integration tests
│   └── README.md
├── bun-app/                        # Bun + Hono
│   ├── .env
│   ├── package.json
│   ├── tsconfig.json
│   ├── drizzle.config.ts
│   ├── drizzle/                   # Drizzle ORM migrations
│   ├── src/
│   │   ├── index.ts               # Hono app entry point
│   │   ├── db/
│   │   │   └── schema.ts          # Drizzle schema definitions
│   │   ├── routes/                # Hono route handlers
│   │   ├── handlers/              # Tasker step handlers
│   │   └── config/
│   │       └── worker.toml
│   ├── tests/
│   │   └── integration.test.ts    # vitest/bun:test integration tests
│   └── README.md
└── axum-app/                       # Rust Axum
    ├── .env
    ├── Cargo.toml
    ├── migrations/                 # sqlx migrations
    ├── src/
    │   ├── main.rs                # Axum app + tasker worker bootstrap
    │   ├── db.rs                  # SQLx connection pool
    │   ├── models.rs              # Domain models
    │   ├── routes/                # Axum route handlers
    │   │   ├── mod.rs
    │   │   ├── orders.rs
    │   │   ├── analytics.rs
    │   │   ├── services.rs
    │   │   └── compliance.rs
    │   └── handlers/              # Tasker step handlers
    │       ├── mod.rs
    │       ├── ecommerce.rs
    │       ├── data_pipeline.rs
    │       ├── microservices.rs
    │       └── team_scaling.rs
    ├── tests/
    │   └── integration.rs
    └── README.md
```

---

## Integration Pattern (All Apps Follow This)

### 1. Worker Bootstrap (app startup)

Each app bootstraps the tasker worker during application startup with web/gRPC **disabled** — the framework's own web server handles HTTP.

**Rails** (initializer):
```ruby
# config/initializers/tasker.rb
require 'tasker_core'
# Returns Hash: { status: "started", worker_id: "...", handle_id: "..." }
TaskerCore::Worker::Bootstrap.start!
```

**FastAPI** (lifespan):
```python
from tasker_core import bootstrap_worker

@asynccontextmanager
async def lifespan(app: FastAPI):
    result = bootstrap_worker()  # Returns BootstrapResult
    yield
    # Worker shuts down with process
```

**Bun** (startup):
```typescript
import { bootstrapWorker, type BootstrapConfig } from "@tasker-systems/tasker";
const result = await bootstrapWorker();  // Returns BootstrapResult
```

**Axum** (main.rs):
```rust
use tasker_worker::WorkerBootstrap;
// Native Rust, no FFI
let worker_handle = WorkerBootstrap::bootstrap().await?;
// Axum server runs on its own; worker runs in background
```

### 2. Task Creation (HTTP endpoint → FFI)

```
POST /orders → Controller creates Order (status=pending) →
  FFI client_create_task(task_request) → receives task_uuid →
  Order.update(task_uuid: uuid, status: processing)
```

### 3. Step Handlers (registered with tasker worker)

Each handler is a framework-native class/function registered with the tasker worker. Handlers receive step data, perform domain logic (update ORM models), and return results.

### 4. Status Queries

```
GET /orders/:id → Load Order → if task_uuid present:
  FFI client_get_task(task_uuid) → return combined status
```

### 5. Background Job Stubs

Each app shows the **pattern** for async job dispatch without requiring extra infrastructure:
- **Rails**: `ActiveJob` class with `perform_later` call (uses inline adapter in dev/test)
- **FastAPI**: Celery task stub with `@celery_app.task` decorator (no broker needed in test)
- **Bun**: Bull queue stub with `queue.add()` pattern (in-memory for test)
- **Axum**: `tokio::spawn` async task (native, no stub needed)

These demonstrate how real apps would trigger post-workflow actions (send email, generate PDF, etc.) without adding Redis/Celery/Bull infrastructure to the examples.

---

## Worker Configuration

Each app's `worker.toml` disables tasker's built-in servers:

```toml
[worker]
name = "example-rails-worker"  # per-app

[worker.web]
enabled = false

[worker.grpc]
enabled = false

[worker.orchestration_client]
base_url = "http://localhost:8080"

[common.database]
url = "postgresql://tasker:tasker@localhost:5432/tasker"
```

---

## Handler Reference Map

Source handlers to reimplement (from `tasker-core/workers/`):

| Workflow | Ruby Source | Python Source | TypeScript Source | Rust Source |
|----------|-----------|---------------|-------------------|-------------|
| E-commerce | `ruby/spec/handlers/examples/blog_examples/blog_post_1_ecommerce/` | `python/tests/handlers/examples/blog_examples/blog_post_1_ecommerce/` | `typescript/tests/handlers/examples/blog_examples/blog_post_1_ecommerce/` | `rust/src/step_handlers/ecommerce.rs` |
| Data Pipeline | `blog_post_2_data_pipeline/` | `blog_post_2_data_pipeline/` | `blog_post_2_data_pipeline/` | `rust/src/step_handlers/data_pipeline.rs` |
| Microservices | `blog_post_3_microservices/` | `blog_post_3_microservices/` | `blog_post_3_microservices/` | `rust/src/step_handlers/microservices.rs` |
| Team Scaling | `blog_post_4_team_scaling/` | `blog_post_4_team_scaling/` | `blog_post_4_team_scaling/` | `rust/src/step_handlers/team_scaling.rs` |

The example app handlers adapt these into framework-native patterns (e.g., using ActiveRecord instead of raw step data manipulation, SQLAlchemy models, Drizzle ORM, SQLx queries).

---

## Per-App Domain Models & Migrations

### Shared Schema Pattern (each app implements in its ORM)

```sql
-- orders (E-commerce workflow)
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_email VARCHAR NOT NULL,
  items JSONB NOT NULL,
  total DECIMAL(10,2) NOT NULL,
  status VARCHAR NOT NULL DEFAULT 'pending',
  task_uuid UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- analytics_jobs (Data pipeline workflow)
CREATE TABLE analytics_jobs (
  id SERIAL PRIMARY KEY,
  source VARCHAR NOT NULL,
  dataset_url VARCHAR,
  status VARCHAR NOT NULL DEFAULT 'pending',
  task_uuid UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- service_requests (Microservices coordination workflow)
CREATE TABLE service_requests (
  id SERIAL PRIMARY KEY,
  user_id VARCHAR NOT NULL,
  request_type VARCHAR NOT NULL,
  status VARCHAR NOT NULL DEFAULT 'pending',
  result JSONB,
  task_uuid UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- compliance_checks (Team scaling workflow)
CREATE TABLE compliance_checks (
  id SERIAL PRIMARY KEY,
  order_ref VARCHAR NOT NULL,
  namespace VARCHAR NOT NULL DEFAULT 'default',
  status VARCHAR NOT NULL DEFAULT 'pending',
  task_uuid UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

Each app uses its **own database** (e.g., `example_rails_dev`) for domain models, separate from tasker's database.

---

## API Endpoints (Each App)

```
# E-commerce
POST   /orders              # Create order → trigger workflow
GET    /orders/:id          # Order status (includes task status)

# Data Pipeline
POST   /analytics/jobs      # Start analytics job → trigger workflow
GET    /analytics/jobs/:id  # Job status

# Microservices
POST   /services/requests   # Create service request → trigger workflow
GET    /services/requests/:id

# Team Scaling
POST   /compliance/checks   # Start compliance check → trigger workflow
GET    /compliance/checks/:id
```

---

## Testing Strategy

### CI Pattern

1. `docker-compose up -d` (shared infrastructure — postgres, orchestration, dragonfly, rabbitmq)
2. Each app's test suite:
   - **before-all**: Bootstrap tasker worker via FFI, run domain migrations
   - **test cases**: POST to create endpoint → poll status until workflow completes → verify domain model updated
   - **after-all**: Shutdown worker, cleanup domain DB

### FFI Bootstrap in Tests

```ruby
# Rails RSpec
before(:all) do
  @bootstrap = TaskerCore::Worker::Bootstrap.start!
  # Returns { status: "started", worker_id: "...", handle_id: "..." }
end
# Worker shuts down with process (idempotent — "already_running" on re-call)
```

```python
# pytest conftest.py
from tasker_core import bootstrap_worker

@pytest.fixture(scope="session", autouse=True)
def tasker_worker():
    result = bootstrap_worker()
    assert result.success
    yield
    # Worker shuts down with process
```

```typescript
// vitest/bun:test setup
import { bootstrapWorker } from "@tasker-systems/tasker";

beforeAll(async () => {
  const result = await bootstrapWorker();
  expect(result.success).toBe(true);
});
```

```rust
// Rust test
use tasker_worker::WorkerBootstrap;

#[tokio::test]
async fn test_order_workflow() {
    let _handle = WorkerBootstrap::bootstrap().await.unwrap();
    // ... test ...
    // Worker drops with handle
}
```

---

## Implementation Phases

### Phase 1: Shared Infrastructure
- `examples/docker-compose.yml`
- `examples/shared/tasker-worker.toml` (base config)
- `examples/shared/README.md`

### Phase 2: Rails App (most familiar pattern, validates approach)
1. `rails new` scaffold (API-only mode)
2. Domain models + migrations (4 tables)
3. Controllers + routes (8 endpoints)
4. Step handlers (4 workflow modules, ~22 handlers total)
5. Tasker initializer (worker bootstrap)
6. Integration tests

### Phase 3: FastAPI App
1. Project scaffold (FastAPI + SQLAlchemy + Alembic)
2. Models + migrations
3. Routes + schemas
4. Step handlers
5. Lifespan bootstrap
6. Integration tests

### Phase 4: Bun App
1. Project scaffold (Bun + Hono + Drizzle)
2. Schema + migrations
3. Routes
4. Step handlers
5. Startup bootstrap
6. Integration tests

### Phase 5: Axum App
1. Cargo project (axum + sqlx + tasker-worker)
2. Models + migrations
3. Route handlers
4. Step handlers (closest to existing `workers/rust/` code)
5. Main with dual bootstrap (axum + tasker-worker)
6. Integration tests

### Phase 6: CI Integration
- Add example app test jobs to `ci.yml`
- Service containers for shared infrastructure
- Per-app language toolchain setup

### Phase 7: Documentation
- Per-app README with setup instructions
- Top-level examples README
- Links from mdBook blog posts to example code

---

## Published Package Dependencies

Each app depends ONLY on published packages (not workspace paths):

| App | Tasker Dependency | Registry |
|-----|-------------------|----------|
| Rails | `gem 'tasker-rb', '~> 0.1.1'` | RubyGems |
| FastAPI | `tasker-py>=0.1.1` | PyPI |
| Bun | `"@tasker-systems/tasker": "^0.1.1"` | npm |
| Axum | `tasker-worker = "0.1.1"`, `tasker-client = "0.1.1"` | crates.io |

**Note**: In CI, FFI packages (tasker-rb, tasker-py, @tasker-systems/tasker) require the native `.dylib`/`.so` — CI builds these via shallow-clone of tasker-core using the existing `build-tasker-core` composite action and cargo-make tooling.

---

## File Count Estimate

| App | Files | Notes |
|-----|-------|-------|
| Shared | ~3 | docker-compose, config, README |
| Rails | ~35 | Standard Rails API structure |
| FastAPI | ~25 | Lean Python project |
| Bun | ~20 | Minimal TypeScript project |
| Axum | ~15 | Compact Rust project |
| **Total** | ~98 | |

---

## Task Template Registration

Task templates are auto-registered by the tasker worker during FFI bootstrap — no seed scripts or API calls needed. Each app provides:

1. **Task template YAML files** in a templates directory (e.g., `config/tasker/templates/`)
2. **`.env` file** with:
   - `TASKER_TEMPLATE_PATH=config/tasker/templates` — directory containing task template YAML files
   - `TASKER_CONFIG_PATH=config/tasker` — directory containing worker.toml
3. **Worker bootstrap call** — the FFI `worker_start()` reads config, discovers templates, and registers them automatically

Each app includes 4 task template YAML files (one per workflow) alongside its worker config.

---

## Open Questions

1. **App-specific databases**: Should each app connect to the same PostgreSQL instance (different database) or should the docker-compose include separate PostgreSQL containers? Recommendation: same instance, separate databases (e.g., `example_rails`, `example_fastapi`, etc.) via init scripts in the postgres container.

2. **Scope per phase**: Given the size (~98 files), should we implement one app at a time as separate PRs, or batch them? Recommendation: one app per PR after shared infrastructure.

---

## Verification

### Local Development
```bash
cd tasker-contrib/examples

# Start infrastructure
docker-compose up -d

# Test one app (e.g., Rails)
cd rails-app
bundle install
rails db:create db:migrate
# .env has TASKER_TEMPLATE_PATH and TASKER_CONFIG_PATH — worker auto-registers templates
bundle exec rspec spec/integration/
```

### CI
- Push branch, open PR → CI runs example app tests per language
- Each job: start services → run migrations → bootstrap worker → run integration tests
