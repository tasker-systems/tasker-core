# TAS-290: Replace koffi C FFI with napi-rs for TypeScript Worker

## Context

The TypeScript worker (`@tasker-systems/tasker`) uses koffi (C FFI) + JSON serialization for the Rust boundary, causing persistent TAS-283 "trailing input" bugs from C string marshalling. Ruby (magnus) and Python (pyo3) both use native object mapping with zero serialization. A completed research spike (`workers/typescript-napi/` on branch `jcoletaylor/tas-290-replace-koffi-with-napi-rs`) proved napi-rs is fully viable — `clientCreateTask()` works end-to-end with no trailing input errors.

This plan migrates `workers/typescript/` from koffi to napi-rs.

## Key Decisions

1. **Field naming**: Use napi-rs default camelCase. Only ~5 internal files need field access updates. Public API (`StepContext.taskUuid`, `StepHandler.call()`, `TaskerClient.createTask()`) is already camelCase — no user-facing changes.

2. **FfiLayer**: Keep as simplified lifecycle manager (load/unload). Drop `TaskerRuntime` interface, `NodeRuntime`, `DenoRuntime`. The napi module IS the runtime.

3. **Types**: Delete `generated/` directory and ts-rs dependency. Use napi-rs auto-generated `index.d.ts` types. Rewrite `ffi/types.ts` with camelCase interfaces.

4. **Structural change**: The napi-rs spike flattens `step_definition.handler.callable` into `stepDefinition.handlerCallable`. StepContext and subscriber must update access patterns accordingly.

---

## Phase 1: Rust FFI Layer (`workers/typescript/src-rust/`)

Replace C FFI with napi-rs exports. The spike has ~80% of the code; this phase fills gaps.

### 1.1 Update Cargo.toml
**File**: `workers/typescript/Cargo.toml`
- Add: `napi = { version = "2", features = ["napi9", "serde-json"] }`, `napi-derive = "2"`
- Add build-dep: `napi-build = "2"`
- Remove: `ts-rs` from dev-deps
- Keep: `crate-type = ["cdylib"]`

### 1.2 Replace build.rs
**File**: `workers/typescript/build.rs`
- Add `napi_build::setup()`
- Keep RUSTC_VERSION capture for `get_rust_version()`

### 1.3 Replace lib.rs
**File**: `workers/typescript/src-rust/lib.rs`
- Copy spike `lib.rs` base (get_version, get_rust_version, health_check)
- Add missing functions not in spike:
  - `is_worker_running() -> Result<bool>`
  - `transition_to_graceful_shutdown() -> Result<WorkerStatus>`
  - `poll_in_process_events() -> Result<Option<NapiDomainEvent>>`
  - `checkpoint_yield_step_event(event_id, checkpoint) -> Result<bool>`
  - `get_ffi_dispatch_metrics() -> Result<NapiDispatchMetrics>`
  - `check_starvation_warnings() -> Result<()>`
  - `cleanup_timeouts() -> Result<()>`
  - `log_error/warn/info/debug/trace(message, fields) -> Result<()>` (5 functions)
- Remove: all `#[no_mangle] extern "C"` functions, `free_rust_string`, C string handling

### 1.4 Replace bridge.rs
**File**: `workers/typescript/src-rust/bridge.rs`
- Copy spike `bridge.rs` (WORKER_SYSTEM, 14 napi object types, bootstrap/poll/complete/status/stop)
- Add missing from existing bridge.rs:
  - `transition_to_graceful_shutdown()` (existing lines 302-328)
  - `poll_in_process_events()` (existing lines 419-470) + new `NapiDomainEvent`, `NapiDomainEventMetadata` structs
  - `checkpoint_yield_step_event()` (existing lines 472-511) + new `NapiCheckpointYieldData` struct
  - `get_ffi_dispatch_metrics()` (existing lines 374-385) + new `NapiDispatchMetrics` struct
  - `check_starvation_warnings()` (existing lines 387-399)
  - `cleanup_timeouts()` (existing lines 401-413)

### 1.5 Replace client_ffi.rs
**File**: `workers/typescript/src-rust/client_ffi.rs`
- Copy spike `client_ffi.rs` (NapiTaskRequest, call_client, create/get/list/cancel/health)
- Add missing: `client_get_step(task_uuid, step_uuid)`, `client_get_step_audit_history(task_uuid, step_uuid)`

### 1.6 Replace error.rs
**File**: `workers/typescript/src-rust/error.rs`
- Copy spike `error.rs` (NapiFfiError → napi::Error)

### 1.7 New ffi_logging.rs
**File**: `workers/typescript/src-rust/ffi_logging.rs`
- 5 `#[napi]` logging functions taking `String` + `Option<HashMap<String, serde_json::Value>>`
- Dispatch to tracing::error/warn/info/debug/trace

### 1.8 Delete files
- DELETE: `src-rust/dto.rs` (682 lines — replaced by `#[napi(object)]` structs)
- DELETE: `src-rust/conversions.rs` (48 lines — no JSON conversion needed)

### 1.9 Verify
```bash
cargo check -p tasker-ts --all-features
cargo clippy --all-targets --all-features -p tasker-ts
```

---

## Phase 2: TypeScript FFI Layer (`workers/typescript/src/ffi/`)

Replace multi-runtime abstraction with simplified napi-rs module loader.

### 2.1 Rewrite ffi-layer.ts
**File**: `src/ffi/ffi-layer.ts`
- Simplified: `load()` uses `require()` to load `.node` file
- `discoverModulePath()` finds `.node` files instead of `.so/.dylib`
- Keep `getRuntime()` as backward-compatible alias for `getModule()`
- Remove: runtime detection, NodeRuntime/DenoRuntime creation, library path discovery

### 2.2 Rewrite types.ts
**File**: `src/ffi/types.ts`
- Remove all ts-rs generated type imports
- Define camelCase interfaces matching napi-rs output:
  - `NapiStepEvent` with `taskUuid`, `stepUuid`, `stepDefinition.handlerCallable` (flattened)
  - `BootstrapResult` with `workerId`
  - `NapiStepResult` (flat: `stepUuid`, `errorMessage`, `errorType`, `errorRetryable`)
  - `NapiDispatchMetrics`, `NapiDomainEvent`, `NapiCheckpointYieldData`
- Keep runtime types: `StepExecutionResult`, `LogFields`, `CheckpointYieldData`
- Type aliases: `export type FfiStepEvent = NapiStepEvent` for compatibility

### 2.3 Simplify ffi/index.ts
**File**: `src/ffi/index.ts`
- Remove: `DenoRuntime`, `NodeRuntime`, `BaseTaskerRuntime`, `TaskerRuntime`, `detectRuntime`, `isBun`, `isNode`, `isDeno`
- Keep: `FfiLayer`, `FfiLayerConfig`, all types

### 2.4 Delete files
- `src/ffi/runtime-interface.ts` (327 lines)
- `src/ffi/node-runtime.ts` (380 lines)
- `src/ffi/deno-runtime.ts`
- `src/ffi/runtime.ts`
- `src/ffi/shims.d.ts`
- `src/ffi/generated/` (21 files)

---

## Phase 3: TypeScript Consumer Rewiring

Update internal consumers for camelCase field names and direct napi module calls.

### 3.1 bootstrap/bootstrap.ts
- Replace `TaskerRuntime` parameter type with napi module type
- `runtime.bootstrapWorker(ffiConfig)` → `module.bootstrapWorker(config)` (native object, no JSON)
- Remove `runtime?.isLoaded` checks

### 3.2 bootstrap/types.ts
- Simplify `toFfiBootstrapConfig()` / `fromFfiBootstrapResult()` — napi output already camelCase, field renaming no longer needed

### 3.3 client/index.ts — **TAS-283 fix**
- `JSON.stringify(request)` → pass typed `NapiTaskRequest` object directly
- `JSON.stringify(params)` → pass typed `NapiListTasksParams` object directly
- `this.ffiLayer.getRuntime()` → `this.ffiLayer.getModule()`

### 3.4 events/event-poller.ts
- `TaskerRuntime` → napi module type
- `event.step_definition.handler.callable` → `event.stepDefinition.handlerCallable`
- `metrics.starvation_detected` → `metrics.starvationDetected`

### 3.5 events/event-system.ts
- Constructor: `TaskerRuntime` → napi module type
- `event.event_id` → `event.eventId`

### 3.6 subscriber/step-execution-subscriber.ts (most changes)
- `event.event_id` → `event.eventId` (throughout)
- `event.step_uuid` → `event.stepUuid`
- `event.step_definition?.handler?.callable` → `event.stepDefinition?.handlerCallable`
- `buildExecutionResult()`: build `NapiStepResult` with flat camelCase fields
- `sendCompletionViaFfi()`: pass typed object instead of JSON

### 3.7 types/step-context.ts
- `event.dependency_results` → `event.dependencyResults`
- `event.step_definition` → `event.stepDefinition`
- `stepDefinition.handler.initialization` → `stepDefinition.handlerInitialization` (flattened)
- `event.workflow_step` → `event.workflowStep`
- `workflowStep.max_attempts` → `workflowStep.maxAttempts`

### 3.8 logging/index.ts
- `TaskerRuntime` → napi module type
- Remove `isLoaded` checks

### 3.9 server/worker-server.ts
- `this.ffiLayer.getRuntime()` → `this.ffiLayer.getModule()` (or keep via alias)
- EventSystem constructor receives napi module

---

## Phase 4: Build & Package

### 4.1 package.json
- Remove: `koffi` from optionalDependencies
- Add: `@napi-rs/cli` to devDependencies
- Update `files`: replace `"native"` with `"*.node"`
- Add build script: `"build:napi": "napi build --platform --release"`

### 4.2 Makefile.toml
- Remove: `generate-bindings` task (no ts-rs)
- Update: `build-ffi` → `npx napi build --platform`
- Remove: `test-ffi-deno`, `test-ffi-node` (single runtime)

### 4.3 Build & test
```bash
cd workers/typescript
bun install
npx napi build --platform --release
bun run build
bun test
```

---

## Phase 5: Tests

- Delete tests for `NodeRuntime`, `DenoRuntime`, `detectRuntime()`
- Update integration tests: snake_case → camelCase field access
- Update client test mocks: typed objects instead of JSON strings
- Run spike test to verify: `bun run test-spike.ts` (copy from typescript-napi/)

---

## Phase 6: CI/Release (separate PR)

- `scripts/ffi-build/build-typescript.sh` → `npx napi build --release --platform --target <triple>`
- `.github/workflows/build-ffi-libraries.yml` → napi build, `.node` artifact names
- `.github/workflows/test-typescript-framework.yml` → simplify multi-runtime to single Bun
- `.github/workflows/release.yml` → bundle `.node` files instead of `.so/.dylib`
- Docker build files → update build commands and library paths

---

## Verification

1. `cargo check -p tasker-ts --all-features` — Rust compiles
2. `npx napi build --platform` — produces `.node` file
3. `bun -e "console.log(require('./tasker_ts.darwin-arm64.node').getVersion())"` — loads in Bun
4. `bun run build && bun test` — TypeScript compiles and tests pass
5. With docker-compose: `RUN_BOOTSTRAP_TESTS=1 bun run test-spike.ts` — full integration


----
# TAS-290 Phase 6: Cleanup, CI/Build Tooling & Validation

## Context

Phases 1-5 of TAS-290 (replacing koffi C FFI with napi-rs) are complete. The TypeScript worker compiles cleanly, all 808 tests pass, and the commit is pushed. What remains is:

1. Remove the `workers/typescript-napi/` research spike and all references
2. Update all build tooling (cargo-make, scripts, CI workflows) from `.so/.dylib` to `.node` output
3. Update documentation to reflect napi-rs instead of koffi
4. Full lifecycle validation via `cargo make`
5. Commit and push

**Key change**: napi-rs produces `.node` files (e.g., `tasker_ts.darwin-arm64.node`) instead of `libtasker_ts.{so,dylib}`. The build uses `cargo build -p tasker-ts` (same as before) but the output is a `.node` file that loads via `require()` instead of a shared library loaded via koffi C FFI.

---

## Step 1: Remove typescript-napi spike

### 1.1 Remove from workspace
**File**: `Cargo.toml` (root, line 37)
- Remove: `"workers/typescript-napi",  # Research: napi-rs FFI spike`

### 1.2 Update Docker workspace stubs
**File**: `docker/scripts/create-workspace-stubs.sh`
- No change needed — `workers/typescript-napi` is not in CRATE_PATHS map

### 1.3 Remove the spike directory
- `rm -rf workers/typescript-napi/` (keeping `docs/ticket-specs/TAS-290.md` as historical reference)

---

## Step 2: Update build scripts

### 2.1 Rewrite `scripts/ffi-build/build-typescript.sh`
**File**: `scripts/ffi-build/build-typescript.sh`

The napi-rs build process differs from C FFI:
- `cargo build -p tasker-ts` still produces a cdylib, but napi-rs's build.rs generates the `.node` binding
- The output file is `libtasker_ts.{so,dylib}` in `target/release/` — this IS the `.node`-compatible file
- For napi-rs, the convention is to rename it to `tasker_ts.<platform>.node`

**New approach**: Keep `cargo build -p tasker-ts --release` but change the artifact copy to produce `.node` files:
```bash
# Map target triple to napi-rs naming convention
# x86_64-unknown-linux-gnu → tasker_ts.linux-x64-gnu.node
# aarch64-apple-darwin → tasker_ts.darwin-arm64.node
```
Copy `libtasker_ts.{so,dylib}` → `tasker_ts.<platform>.node` in artifacts dir.

### 2.2 Update `scripts/ffi-build/verify-artifacts.sh`
**File**: `scripts/ffi-build/verify-artifacts.sh` (lines 196-213)

Update `verify_typescript()` to look for `.node` files instead of `.so/.dylib`:
- `tasker_ts-${TARGET}.node` (or the napi naming convention)

### 2.3 Update `cargo-make/scripts/ci-restore-typescript-artifacts.sh`
**File**: `cargo-make/scripts/ci-restore-typescript-artifacts.sh`

Replace `.so/.dylib` references with `.node` file handling:
- Look for `tasker_ts.*.node` files instead of `libtasker_ts.{so,dylib}`
- Copy to `workers/typescript/` (package root, where `findBundledNodeModule()` looks)
- Set `TASKER_FFI_MODULE_PATH` instead of `TASKER_FFI_LIBRARY_PATH`

### 2.4 Update `cargo-make/scripts/ci-restore-all-artifacts.sh`
**File**: `cargo-make/scripts/ci-restore-all-artifacts.sh` (line 17)
- Update comment: `typescript/ → typescript-artifacts (dist/, tasker_ts.*.node)`

---

## Step 3: Update CI workflows

### 3.1 `build-workers.yml` — build-typescript job
**File**: `.github/workflows/build-workers.yml` (lines 287-296)

Update artifact upload:
```yaml
- name: Upload TypeScript artifacts
  uses: actions/upload-artifact@v6
  with:
    name: typescript-artifacts
    path: |
      workers/typescript/dist/
      workers/typescript/tasker_ts.*.node
    retention-days: 1
    if-no-files-found: warn
```

Also add Node.js setup step (for `npx napi` if needed, though `cargo make build` in the Makefile.toml currently uses `cargo build` directly — no npx needed for debug builds).

### 3.2 `test-typescript-framework.yml`
**File**: `.github/workflows/test-typescript-framework.yml`

Changes:
- **Remove** lines 64-67: Setup Deno step (no longer needed)
- **Remove** lines 137-162: koffi comments, Node.js FFI test step (`node-runtime.test.ts` deleted), Deno FFI test step (`deno-runtime.test.ts` deleted)
- **Update** lines 104-119: "Setup FFI library path" step — look for `.node` files instead of `.so/.dylib`, set `TASKER_FFI_MODULE_PATH`
- **Remove** from upload artifacts (lines 216-218): `typescript-ffi-node-results.txt`, `typescript-ffi-deno-results.txt`
- **Add**: napi-rs FFI integration test step using `cargo make test-ffi` (replaces Node/Deno separate steps)

### 3.3 `build-ffi-libraries.yml`
**File**: `.github/workflows/build-ffi-libraries.yml`

No direct changes needed — this workflow calls `scripts/ffi-build/build-all.sh` which calls `build-typescript.sh`. The artifact naming flows through the script updates in Step 2.

### 3.4 `release.yml` — TypeScript publish job
**File**: `.github/workflows/release.yml` (lines 459-482)

Update "Bundle native libraries into package":
```yaml
- name: Bundle native libraries into package
  run: |
    BUNDLED=0
    try_bundle() { ... }
    try_bundle "ffi-artifacts/typescript/tasker_ts-x86_64-unknown-linux-gnu.node" \
               "workers/typescript/tasker_ts.linux-x64-gnu.node" "linux-x64"
    try_bundle "ffi-artifacts/typescript/tasker_ts-aarch64-apple-darwin.node" \
               "workers/typescript/tasker_ts.darwin-arm64.node" "darwin-arm64"
```

Remove `mkdir -p workers/typescript/native` — `.node` files go directly in package root (matching `package.json` `"files": ["*.node"]`).

Also **remove** the `Setup Node.js` step (lines 446-449) — not needed for napi-rs publishing.

---

## Step 4: Update `workers/typescript/Makefile.toml`

### 4.1 Add `test-ffi-all` alias
The Makefile.toml already has `test-ffi` for napi-rs tests. Add a `test-ffi-all` alias that CI can use:
```toml
[tasks.test-ffi-all]
description = "Run all FFI integration tests (alias for test-ffi)"
alias = "test-ffi"
```

### 4.2 Verify build-ffi task
Current `build-ffi` uses `cargo build -p tasker-ts` which is correct for napi-rs. The `.node` file is produced as `libtasker_ts.{so,dylib}` in `target/debug/` — the FfiLayer's `findBundledNodeModule()` and `TASKER_FFI_MODULE_PATH`/`TASKER_FFI_LIBRARY_PATH` env vars handle discovery.

---

## Step 5: Update documentation

### 5.1 `docs/workers/typescript.md`
- Line 45: `TASKER_FFI_LIBRARY_PATH` → add `TASKER_FFI_MODULE_PATH` (preferred) with backward compat note
- Line 114: `libtasker_ts.dylib` → `.node` file
- Lines 170-171: Replace koffi runtime table with napi-rs single-runtime info
- Lines 981-982: Remove `node-runtime.ts`, `deno-runtime.ts` from directory listing
- Lines 1174/1180: Update Docker example to use `.node` file

### 5.2 `docs/workers/README.md`
- Line 198: `libtasker_ts.dylib` → `.node` file reference

### 5.3 `docs/workers/memory-management.md`
- Line 426: `BunTaskerRuntime()` → update to `FfiLayer` pattern
- Line 456: Remove raw pointer reference (no longer applicable with napi-rs)

### 5.4 `workers/typescript/AGENTS.md`
- Line 38: `libtasker_ts.*` → `.node` file
- Lines 76-77: Replace koffi runtime table with napi-rs
- Line 84: `libtasker_ts.{dylib,so,dll}` → `.node` file
- Line 125: Artifact references
- Lines 135-136: Remove `node-runtime.ts`/`deno-runtime.ts` references
- Line 153: `libtasker_ts.*` → `.node` file

### 5.5 `docs/development/best-practices-typescript.md`
- Review and update any koffi/multi-runtime references

---

## Step 6: Ensure npx/Node.js availability

The `@napi-rs/cli` is already in `package.json` devDependencies. `npx napi build` works after `bun install` since Bun resolves npx-style commands from `node_modules/.bin/`.

**CI**: Node.js is already set up in `test-typescript-framework.yml` (line 59-62). The `build-workers.yml` job only needs Bun + Rust (no npx needed since it uses `cargo build` directly).

**Local dev**: No changes needed to `Brewfile` or `bin/setup-dev.sh` — the napi build is invoked via `cargo build -p tasker-ts`, not via `npx napi build`. The `npx napi build --platform` script in package.json is a convenience for manual use.

---

## Step 7: Full lifecycle validation

After all changes, run the complete cargo-make lifecycle:

```bash
# 1. Clean
cargo make clean

# 2. Build (includes TypeScript FFI + TS compilation)
cargo make build

# 3. Fix (auto-fix lint issues)
cargo make fix

# 4. Code quality (requires orchestration server for client tests)
cargo make services-stop
cargo make run-orchestration
cargo make code-quality

# 5. Reload services and run full test suite
cargo make services-stop
cargo make services-start
cargo make test-rust-unit
cargo make test-rust-e2e
```

If any step fails, investigate and fix before committing.

---

## Step 8: Commit and push

Stage all changes and commit with a descriptive message about the cleanup.

---

## Step 9: Update tasker-contrib bun-app (secondary validation)

**After** the cleanup commit, update `../tasker-contrib/examples/bun-app` to use local tasker-core's TypeScript client:

1. In `tasker-contrib/examples/bun-app/package.json`, change `"@tasker-systems/tasker": "0.1.4"` to point at local path: `"@tasker-systems/tasker": "file:../../../../tasker-core/workers/typescript"`
2. Run `bun install` to link the local package
3. Run integration tests against docker-compose infrastructure to confirm end-to-end workflow execution

This validates that the napi-rs approach works in a real consumer context, not just in unit tests.

---

## Files Modified (Summary)

| Category | Files |
|----------|-------|
| **Remove** | `workers/typescript-napi/` (entire directory), line in root `Cargo.toml` |
| **Build scripts** | `scripts/ffi-build/build-typescript.sh`, `scripts/ffi-build/verify-artifacts.sh` |
| **CI restore** | `cargo-make/scripts/ci-restore-typescript-artifacts.sh`, `cargo-make/scripts/ci-restore-all-artifacts.sh` |
| **CI workflows** | `build-workers.yml`, `test-typescript-framework.yml`, `release.yml` |
| **Makefile** | `workers/typescript/Makefile.toml` |
| **Docs** | `docs/workers/typescript.md`, `docs/workers/README.md`, `docs/workers/memory-management.md`, `workers/typescript/AGENTS.md`, `docs/development/best-practices-typescript.md` |
