# TAS-290: Replace koffi C FFI with napi-rs for TypeScript Worker

## Context

The TypeScript worker (`@tasker-systems/tasker`) uses koffi (C FFI) + JSON serialization for the Rust boundary, causing persistent TAS-283 "trailing input" bugs from C string marshalling. Ruby (magnus) and Python (pyo3) both use native object mapping with zero serialization. A completed research spike (`workers/typescript-napi/` on branch `jcoletaylor/tas-290-replace-koffi-with-napi-rs`) proved napi-rs is fully viable — `clientCreateTask()` works end-to-end with no trailing input errors.

This plan migrates `workers/typescript/` from koffi to napi-rs.

## Key Decisions

1. **Field naming**: Use napi-rs default camelCase. Only ~5 internal files need field access updates. Public API (`StepContext.taskUuid`, `StepHandler.call()`, `TaskerClient.createTask()`) is already camelCase — no user-facing changes.

2. **FfiLayer**: Keep as simplified lifecycle manager (load/unload). Drop `TaskerRuntime` interface, `NodeRuntime`, `DenoRuntime`. The napi module IS the runtime.

3. **Types**: Delete `generated/` directory and ts-rs dependency. Use napi-rs auto-generated `index.d.ts` types. Rewrite `ffi/types.ts` with camelCase interfaces.

4. **Structural change**: The napi-rs spike flattens `step_definition.handler.callable` into `stepDefinition.handlerCallable`. StepContext and subscriber must update access patterns accordingly.

---

## Phase 1: Rust FFI Layer (`workers/typescript/src-rust/`)

Replace C FFI with napi-rs exports. The spike has ~80% of the code; this phase fills gaps.

### 1.1 Update Cargo.toml
**File**: `workers/typescript/Cargo.toml`
- Add: `napi = { version = "2", features = ["napi9", "serde-json"] }`, `napi-derive = "2"`
- Add build-dep: `napi-build = "2"`
- Remove: `ts-rs` from dev-deps
- Keep: `crate-type = ["cdylib"]`

### 1.2 Replace build.rs
**File**: `workers/typescript/build.rs`
- Add `napi_build::setup()`
- Keep RUSTC_VERSION capture for `get_rust_version()`

### 1.3 Replace lib.rs
**File**: `workers/typescript/src-rust/lib.rs`
- Copy spike `lib.rs` base (get_version, get_rust_version, health_check)
- Add missing functions not in spike:
  - `is_worker_running() -> Result<bool>`
  - `transition_to_graceful_shutdown() -> Result<WorkerStatus>`
  - `poll_in_process_events() -> Result<Option<NapiDomainEvent>>`
  - `checkpoint_yield_step_event(event_id, checkpoint) -> Result<bool>`
  - `get_ffi_dispatch_metrics() -> Result<NapiDispatchMetrics>`
  - `check_starvation_warnings() -> Result<()>`
  - `cleanup_timeouts() -> Result<()>`
  - `log_error/warn/info/debug/trace(message, fields) -> Result<()>` (5 functions)
- Remove: all `#[no_mangle] extern "C"` functions, `free_rust_string`, C string handling

### 1.4 Replace bridge.rs
**File**: `workers/typescript/src-rust/bridge.rs`
- Copy spike `bridge.rs` (WORKER_SYSTEM, 14 napi object types, bootstrap/poll/complete/status/stop)
- Add missing from existing bridge.rs:
  - `transition_to_graceful_shutdown()` (existing lines 302-328)
  - `poll_in_process_events()` (existing lines 419-470) + new `NapiDomainEvent`, `NapiDomainEventMetadata` structs
  - `checkpoint_yield_step_event()` (existing lines 472-511) + new `NapiCheckpointYieldData` struct
  - `get_ffi_dispatch_metrics()` (existing lines 374-385) + new `NapiDispatchMetrics` struct
  - `check_starvation_warnings()` (existing lines 387-399)
  - `cleanup_timeouts()` (existing lines 401-413)

### 1.5 Replace client_ffi.rs
**File**: `workers/typescript/src-rust/client_ffi.rs`
- Copy spike `client_ffi.rs` (NapiTaskRequest, call_client, create/get/list/cancel/health)
- Add missing: `client_get_step(task_uuid, step_uuid)`, `client_get_step_audit_history(task_uuid, step_uuid)`

### 1.6 Replace error.rs
**File**: `workers/typescript/src-rust/error.rs`
- Copy spike `error.rs` (NapiFfiError → napi::Error)

### 1.7 New ffi_logging.rs
**File**: `workers/typescript/src-rust/ffi_logging.rs`
- 5 `#[napi]` logging functions taking `String` + `Option<HashMap<String, serde_json::Value>>`
- Dispatch to tracing::error/warn/info/debug/trace

### 1.8 Delete files
- DELETE: `src-rust/dto.rs` (682 lines — replaced by `#[napi(object)]` structs)
- DELETE: `src-rust/conversions.rs` (48 lines — no JSON conversion needed)

### 1.9 Verify
```bash
cargo check -p tasker-ts --all-features
cargo clippy --all-targets --all-features -p tasker-ts
```

---

## Phase 2: TypeScript FFI Layer (`workers/typescript/src/ffi/`)

Replace multi-runtime abstraction with simplified napi-rs module loader.

### 2.1 Rewrite ffi-layer.ts
**File**: `src/ffi/ffi-layer.ts`
- Simplified: `load()` uses `require()` to load `.node` file
- `discoverModulePath()` finds `.node` files instead of `.so/.dylib`
- Keep `getRuntime()` as backward-compatible alias for `getModule()`
- Remove: runtime detection, NodeRuntime/DenoRuntime creation, library path discovery

### 2.2 Rewrite types.ts
**File**: `src/ffi/types.ts`
- Remove all ts-rs generated type imports
- Define camelCase interfaces matching napi-rs output:
  - `NapiStepEvent` with `taskUuid`, `stepUuid`, `stepDefinition.handlerCallable` (flattened)
  - `BootstrapResult` with `workerId`
  - `NapiStepResult` (flat: `stepUuid`, `errorMessage`, `errorType`, `errorRetryable`)
  - `NapiDispatchMetrics`, `NapiDomainEvent`, `NapiCheckpointYieldData`
- Keep runtime types: `StepExecutionResult`, `LogFields`, `CheckpointYieldData`
- Type aliases: `export type FfiStepEvent = NapiStepEvent` for compatibility

### 2.3 Simplify ffi/index.ts
**File**: `src/ffi/index.ts`
- Remove: `DenoRuntime`, `NodeRuntime`, `BaseTaskerRuntime`, `TaskerRuntime`, `detectRuntime`, `isBun`, `isNode`, `isDeno`
- Keep: `FfiLayer`, `FfiLayerConfig`, all types

### 2.4 Delete files
- `src/ffi/runtime-interface.ts` (327 lines)
- `src/ffi/node-runtime.ts` (380 lines)
- `src/ffi/deno-runtime.ts`
- `src/ffi/runtime.ts`
- `src/ffi/shims.d.ts`
- `src/ffi/generated/` (21 files)

---

## Phase 3: TypeScript Consumer Rewiring

Update internal consumers for camelCase field names and direct napi module calls.

### 3.1 bootstrap/bootstrap.ts
- Replace `TaskerRuntime` parameter type with napi module type
- `runtime.bootstrapWorker(ffiConfig)` → `module.bootstrapWorker(config)` (native object, no JSON)
- Remove `runtime?.isLoaded` checks

### 3.2 bootstrap/types.ts
- Simplify `toFfiBootstrapConfig()` / `fromFfiBootstrapResult()` — napi output already camelCase, field renaming no longer needed

### 3.3 client/index.ts — **TAS-283 fix**
- `JSON.stringify(request)` → pass typed `NapiTaskRequest` object directly
- `JSON.stringify(params)` → pass typed `NapiListTasksParams` object directly
- `this.ffiLayer.getRuntime()` → `this.ffiLayer.getModule()`

### 3.4 events/event-poller.ts
- `TaskerRuntime` → napi module type
- `event.step_definition.handler.callable` → `event.stepDefinition.handlerCallable`
- `metrics.starvation_detected` → `metrics.starvationDetected`

### 3.5 events/event-system.ts
- Constructor: `TaskerRuntime` → napi module type
- `event.event_id` → `event.eventId`

### 3.6 subscriber/step-execution-subscriber.ts (most changes)
- `event.event_id` → `event.eventId` (throughout)
- `event.step_uuid` → `event.stepUuid`
- `event.step_definition?.handler?.callable` → `event.stepDefinition?.handlerCallable`
- `buildExecutionResult()`: build `NapiStepResult` with flat camelCase fields
- `sendCompletionViaFfi()`: pass typed object instead of JSON

### 3.7 types/step-context.ts
- `event.dependency_results` → `event.dependencyResults`
- `event.step_definition` → `event.stepDefinition`
- `stepDefinition.handler.initialization` → `stepDefinition.handlerInitialization` (flattened)
- `event.workflow_step` → `event.workflowStep`
- `workflowStep.max_attempts` → `workflowStep.maxAttempts`

### 3.8 logging/index.ts
- `TaskerRuntime` → napi module type
- Remove `isLoaded` checks

### 3.9 server/worker-server.ts
- `this.ffiLayer.getRuntime()` → `this.ffiLayer.getModule()` (or keep via alias)
- EventSystem constructor receives napi module

---

## Phase 4: Build & Package

### 4.1 package.json
- Remove: `koffi` from optionalDependencies
- Add: `@napi-rs/cli` to devDependencies
- Update `files`: replace `"native"` with `"*.node"`
- Add build script: `"build:napi": "napi build --platform --release"`

### 4.2 Makefile.toml
- Remove: `generate-bindings` task (no ts-rs)
- Update: `build-ffi` → `npx napi build --platform`
- Remove: `test-ffi-deno`, `test-ffi-node` (single runtime)

### 4.3 Build & test
```bash
cd workers/typescript
bun install
npx napi build --platform --release
bun run build
bun test
```

---

## Phase 5: Tests

- Delete tests for `NodeRuntime`, `DenoRuntime`, `detectRuntime()`
- Update integration tests: snake_case → camelCase field access
- Update client test mocks: typed objects instead of JSON strings
- Run spike test to verify: `bun run test-spike.ts` (copy from typescript-napi/)

---

## Phase 6: CI/Release (separate PR)

- `scripts/ffi-build/build-typescript.sh` → `npx napi build --release --platform --target <triple>`
- `.github/workflows/build-ffi-libraries.yml` → napi build, `.node` artifact names
- `.github/workflows/test-typescript-framework.yml` → simplify multi-runtime to single Bun
- `.github/workflows/release.yml` → bundle `.node` files instead of `.so/.dylib`
- Docker build files → update build commands and library paths

---

## Verification

1. `cargo check -p tasker-ts --all-features` — Rust compiles
2. `npx napi build --platform` — produces `.node` file
3. `bun -e "console.log(require('./tasker_ts.darwin-arm64.node').getVersion())"` — loads in Bun
4. `bun run build && bun test` — TypeScript compiles and tests pass
5. With docker-compose: `RUN_BOOTSTRAP_TESTS=1 bun run test-spike.ts` — full integration
