//! Rust struct code generation.

use askama::Template;

use super::schema::{FieldType, TypeDef};
use super::CodegenError;

#[derive(Template, Debug)]
#[template(path = "codegen/rust_structs.rs")]
struct RustTemplate<'a> {
    types: &'a [TypeDef],
    needs_json_value: bool,
    needs_hashmap: bool,
}

/// Render Rust structs from type definitions.
pub fn render(types: &[TypeDef]) -> Result<String, CodegenError> {
    let all_field_types: Vec<&FieldType> = types
        .iter()
        .flat_map(|t| &t.fields)
        .map(|f| &f.field_type)
        .collect();

    let needs_json_value = all_field_types.iter().any(|ft| uses_json_value(ft));
    let needs_hashmap = all_field_types.iter().any(|ft| uses_hashmap(ft));

    let template = RustTemplate {
        types,
        needs_json_value,
        needs_hashmap,
    };
    template
        .render()
        .map_err(|e| CodegenError::Rendering(e.to_string()))
}

fn uses_json_value(ft: &FieldType) -> bool {
    match ft {
        FieldType::Any => true,
        FieldType::Array(inner) | FieldType::Map(inner) => uses_json_value(inner),
        _ => false,
    }
}

fn uses_hashmap(ft: &FieldType) -> bool {
    match ft {
        FieldType::Map(_) => true,
        FieldType::Array(inner) => uses_hashmap(inner),
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::schema::FieldDef;

    #[test]
    fn test_rust_flat_types() {
        let types = vec![TypeDef {
            name: "ValidateOrderResult".to_string(),
            description: Some("Order validation".to_string()),
            fields: vec![
                FieldDef {
                    name: "validated".to_string(),
                    field_type: FieldType::Boolean,
                    required: true,
                    description: None,
                },
                FieldDef {
                    name: "order_total".to_string(),
                    field_type: FieldType::Number,
                    required: true,
                    description: None,
                },
                FieldDef {
                    name: "notes".to_string(),
                    field_type: FieldType::String,
                    required: false,
                    description: None,
                },
            ],
        }];

        let output = render(&types).unwrap();
        assert!(output.contains("pub struct ValidateOrderResult {"));
        assert!(output.contains("pub validated: bool,"));
        assert!(output.contains("pub order_total: f64,"));
        assert!(output.contains("pub notes: Option<String>,"));
        assert!(output
            .contains("#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]"));
    }

    #[test]
    fn test_rust_empty_types() {
        let output = render(&[]).unwrap();
        assert!(output.contains("Generated by tasker-ctl"));
        assert!(!output.contains("pub struct"));
    }
}
