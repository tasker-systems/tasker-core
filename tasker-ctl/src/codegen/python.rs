//! Python Pydantic BaseModel code generation.

use askama::Template;

use super::schema::{FieldType, TypeDef};
use super::CodegenError;

#[derive(Template, Debug)]
#[template(path = "codegen/python_models.py")]
struct PythonTemplate<'a> {
    types: &'a [TypeDef],
    needs_any: bool,
}

/// Render Python Pydantic models from type definitions.
pub fn render(types: &[TypeDef]) -> Result<String, CodegenError> {
    let needs_any = types
        .iter()
        .flat_map(|t| &t.fields)
        .any(|f| uses_any(&f.field_type));

    let template = PythonTemplate { types, needs_any };
    template
        .render()
        .map_err(|e| CodegenError::Rendering(e.to_string()))
}

fn uses_any(ft: &FieldType) -> bool {
    match ft {
        FieldType::Any => true,
        FieldType::Array(inner) => uses_any(inner),
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::schema::{FieldDef, FieldType};

    #[test]
    fn test_python_flat_types() {
        let types = vec![TypeDef {
            name: "ValidateOrderResult".to_string(),
            description: Some("Order validation result".to_string()),
            fields: vec![
                FieldDef {
                    name: "validated".to_string(),
                    field_type: FieldType::Boolean,
                    required: true,
                    description: None,
                },
                FieldDef {
                    name: "order_total".to_string(),
                    field_type: FieldType::Number,
                    required: true,
                    description: None,
                },
                FieldDef {
                    name: "notes".to_string(),
                    field_type: FieldType::String,
                    required: false,
                    description: None,
                },
            ],
        }];

        let output = render(&types).unwrap();
        assert!(output.contains("class ValidateOrderResult(BaseModel):"));
        assert!(output.contains("validated: bool"));
        assert!(output.contains("order_total: float"));
        assert!(output.contains("notes: Optional[str] = None"));
        assert!(output.contains("\"\"\"Order validation result\"\"\""));
    }

    #[test]
    fn test_python_empty_types() {
        let output = render(&[]).unwrap();
        assert!(output.contains("Generated by tasker-ctl"));
        assert!(!output.contains("class "));
    }

    #[test]
    fn test_python_array_types() {
        let types = vec![TypeDef {
            name: "ListResult".to_string(),
            description: None,
            fields: vec![FieldDef {
                name: "items".to_string(),
                field_type: FieldType::Array(Box::new(FieldType::String)),
                required: true,
                description: None,
            }],
        }];

        let output = render(&types).unwrap();
        assert!(output.contains("items: list[str]"));
    }
}
