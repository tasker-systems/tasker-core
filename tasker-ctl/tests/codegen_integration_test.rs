//! Integration tests for `tasker-ctl generate types` (TAS-280)
//!
//! Tests the full CLI pipeline: YAML parsing → schema extraction → code generation.
//! Uses the codegen_test_template.yaml fixture which covers flat types, nested objects,
//! arrays, optional fields, and steps without result_schema.
//!
//! The fixture has namespace_name: "codegen_tests", so result types are prefixed
//! with `CodegenTests` (e.g. `CodegenTestsValidateOrderResult`).

use std::path::{Path, PathBuf};
use std::process::Command;

/// Get the path to the compiled tasker-ctl binary.
fn tasker_ctl_bin() -> PathBuf {
    PathBuf::from(env!("CARGO_BIN_EXE_tasker-ctl"))
}

/// Path to the codegen test fixture.
fn fixture_path() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("../tests/fixtures/task_templates/codegen_test_template.yaml")
}

/// Run `tasker-ctl generate types` with given language and optional extra args.
fn generate_types(language: &str, extra_args: &[&str]) -> std::process::Output {
    let mut args = vec!["generate", "types", "--template"];
    let fixture = fixture_path();
    let fixture_str = fixture.to_str().unwrap();
    args.push(fixture_str);
    args.push("--language");
    args.push(language);
    args.extend_from_slice(extra_args);

    Command::new(tasker_ctl_bin())
        .args(&args)
        .output()
        .expect("Failed to execute tasker-ctl")
}

// ── Python ──────────────────────────────────────────────────────────

#[test]
fn test_generate_python_types() {
    let output = generate_types("python", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Header
    assert!(stdout.contains("Generated by tasker-ctl"));
    assert!(stdout.contains("from pydantic import BaseModel"));

    // Input type (from input_schema) — should appear before result types
    assert!(stdout.contains("class CodegenTestInputItems(BaseModel):"));
    assert!(stdout.contains("class CodegenTestInputShippingAddress(BaseModel):"));
    assert!(stdout.contains("class CodegenTestInput(BaseModel):"));

    // Input type field assertions
    assert!(stdout.contains("order_id: str"));
    assert!(stdout.contains("customer_email: str"));
    assert!(stdout.contains("items: list[CodegenTestInputItems]"));

    // Input type appears before result types
    let input_pos = stdout.find("class CodegenTestInput(BaseModel):").unwrap();
    let result_pos = stdout
        .find("class CodegenTestsValidateOrderResult(BaseModel):")
        .unwrap();
    assert!(
        input_pos < result_pos,
        "Input type should appear before result types"
    );

    // CodegenTestsValidateOrderResult (namespace-prefixed)
    assert!(stdout.contains("class CodegenTestsValidateOrderResult(BaseModel):"));
    assert!(stdout.contains("validated: bool"));
    assert!(stdout.contains("order_total: float"));
    assert!(stdout.contains("item_count: int"));
    assert!(stdout.contains("notes: Optional[str] = None"));

    // CodegenTestsEnrichOrderResult with nested Metadata
    assert!(stdout.contains("class CodegenTestsEnrichOrderResultMetadata(BaseModel):"));
    assert!(stdout.contains("class CodegenTestsEnrichOrderResult(BaseModel):"));

    // CodegenTestsGenerateReportResult with arrays
    assert!(stdout.contains("class CodegenTestsGenerateReportResult(BaseModel):"));
    assert!(stdout.contains("line_items: list[str]"));

    // process_payment has no result_schema — should NOT generate types
    assert!(!stdout.contains("ProcessPayment"));

    // ── Map types (aggregate_metrics step) ──
    assert!(stdout.contains("class CodegenTestsAggregateMetricsResult(BaseModel):"));

    // Simple map: additionalProperties with primitive value
    assert!(stdout.contains("scores: dict[str, float]"));

    // Map with nested object value type
    assert!(stdout
        .contains("daily_breakdown: dict[str, CodegenTestsAggregateMetricsResultDailyBreakdown]"));

    // Open map: additionalProperties: true
    assert!(stdout.contains("extra: Optional[dict[str, Any]]"));
}

// ── Ruby ────────────────────────────────────────────────────────────

#[test]
fn test_generate_ruby_types() {
    let output = generate_types("ruby", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Input type (from input_schema)
    assert!(stdout.contains("class CodegenTestInput < Dry::Struct"));
    assert!(stdout.contains("class CodegenTestInputItems < Dry::Struct"));
    assert!(stdout.contains("class CodegenTestInputShippingAddress < Dry::Struct"));

    // Namespace-prefixed result types
    assert!(stdout.contains("class CodegenTestsValidateOrderResult < Dry::Struct"));
    assert!(stdout.contains("attribute :validated, Types::Strict::Bool"));
    assert!(stdout.contains("attribute :order_total, Types::Strict::Float"));
    assert!(stdout.contains("attribute :item_count, Types::Strict::Integer"));

    assert!(stdout.contains("class CodegenTestsEnrichOrderResultMetadata < Dry::Struct"));
    assert!(stdout.contains("class CodegenTestsEnrichOrderResult < Dry::Struct"));
    assert!(stdout.contains("class CodegenTestsGenerateReportResult < Dry::Struct"));

    assert!(!stdout.contains("ProcessPayment"));

    // ── Map types (aggregate_metrics step) ──
    assert!(stdout.contains("class CodegenTestsAggregateMetricsResult < Dry::Struct"));
    assert!(stdout.contains("Types::Strict::Hash.map(Types::Strict::String, Types::Strict::Float)"));
    assert!(stdout.contains("Types::Nominal::Any"));
}

// ── TypeScript ──────────────────────────────────────────────────────

#[test]
fn test_generate_typescript_types() {
    let output = generate_types("typescript", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Zod import
    assert!(stdout.contains("import { z } from 'zod';"));

    // No plain interfaces — Zod schemas are the single source of truth
    assert!(!stdout.contains("export interface"));

    // Input type (from input_schema) — Zod schemas with inferred types
    assert!(stdout.contains("export const CodegenTestInputSchema = z.object({"));
    assert!(
        stdout.contains("export type CodegenTestInput = z.infer<typeof CodegenTestInputSchema>;")
    );
    assert!(stdout.contains("export const CodegenTestInputItemsSchema = z.object({"));
    assert!(stdout.contains("export const CodegenTestInputShippingAddressSchema = z.object({"));

    // Namespace-prefixed result types — field-level assertions
    assert!(stdout.contains("export const CodegenTestsValidateOrderResultSchema = z.object({"));
    assert!(stdout.contains("validated: z.boolean(),"));
    assert!(stdout.contains("order_total: z.number(),"));
    assert!(stdout.contains("item_count: z.number().int(),"));
    assert!(stdout.contains("notes: z.string().optional(),"));
    assert!(stdout.contains(
        "export type CodegenTestsValidateOrderResult = z.infer<typeof CodegenTestsValidateOrderResultSchema>;"
    ));

    // Nested and array types
    assert!(
        stdout.contains("export const CodegenTestsEnrichOrderResultMetadataSchema = z.object({")
    );
    assert!(stdout.contains("export const CodegenTestsEnrichOrderResultSchema = z.object({"));
    assert!(stdout.contains("export const CodegenTestsGenerateReportResultSchema = z.object({"));

    // process_payment has no result_schema — should NOT generate types
    assert!(!stdout.contains("ProcessPayment"));

    // ── Map types (aggregate_metrics step) ──
    assert!(stdout.contains("export const CodegenTestsAggregateMetricsResultSchema = z.object({"));
    assert!(stdout.contains("z.record(z.string(), z.number())"));
    assert!(stdout
        .contains("z.record(z.string(), CodegenTestsAggregateMetricsResultDailyBreakdownSchema)"));
    assert!(stdout.contains("z.record(z.string(), z.unknown())"));
}

// ── Rust ────────────────────────────────────────────────────────────

#[test]
fn test_generate_rust_types() {
    let output = generate_types("rust", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Input type (from input_schema)
    assert!(stdout.contains("pub struct CodegenTestInput {"));
    assert!(stdout.contains("pub struct CodegenTestInputItems {"));
    assert!(stdout.contains("pub struct CodegenTestInputShippingAddress {"));

    // Namespace-prefixed result types
    assert!(stdout.contains("pub struct CodegenTestsValidateOrderResult {"));
    assert!(stdout.contains("pub validated: bool,"));
    assert!(stdout.contains("pub order_total: f64,"));
    assert!(stdout.contains("pub item_count: i64,"));
    assert!(stdout.contains("pub notes: Option<String>,"));
    assert!(
        stdout.contains("#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]")
    );

    assert!(stdout.contains("pub struct CodegenTestsEnrichOrderResultMetadata {"));
    assert!(stdout.contains("pub struct CodegenTestsEnrichOrderResult {"));
    assert!(stdout.contains("pub struct CodegenTestsGenerateReportResult {"));

    assert!(!stdout.contains("ProcessPayment"));

    // ── Map types (aggregate_metrics step) ──
    assert!(stdout.contains("pub struct CodegenTestsAggregateMetricsResult {"));
    assert!(stdout.contains("std::collections::HashMap<String, f64>"));
    assert!(stdout.contains(
        "std::collections::HashMap<String, CodegenTestsAggregateMetricsResultDailyBreakdown>"
    ));
    assert!(stdout.contains("std::collections::HashMap<String, Value>"));
}

// ── Step filter ─────────────────────────────────────────────────────

#[test]
fn test_generate_types_with_step_filter() {
    let output = generate_types("python", &["--step", "validate_order"]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Only validate_order types should appear (namespace-prefixed)
    assert!(stdout.contains("class CodegenTestsValidateOrderResult(BaseModel):"));

    // Input type should NOT appear when step filter is active
    assert!(!stdout.contains("CodegenTestInput"));

    // Other steps should NOT appear
    assert!(!stdout.contains("EnrichOrder"));
    assert!(!stdout.contains("GenerateReport"));
}

// ── Language aliases ────────────────────────────────────────────────

#[test]
fn test_generate_types_language_aliases() {
    for (alias, expected) in [
        ("py", "class CodegenTestsValidateOrderResult(BaseModel):"),
        ("rb", "class CodegenTestsValidateOrderResult < Dry::Struct"),
        (
            "ts",
            "export const CodegenTestsValidateOrderResultSchema = z.object({",
        ),
        ("rs", "pub struct CodegenTestsValidateOrderResult {"),
    ] {
        let output = generate_types(alias, &["--step", "validate_order"]);
        let stdout = String::from_utf8_lossy(&output.stdout);
        assert!(
            output.status.success(),
            "alias '{}' failed: {}",
            alias,
            String::from_utf8_lossy(&output.stderr)
        );
        assert!(
            stdout.contains(expected),
            "alias '{}' output missing '{}' in:\n{}",
            alias,
            expected,
            stdout
        );
    }
}

// ── Error cases ─────────────────────────────────────────────────────

#[test]
fn test_generate_types_file_not_found() {
    let output = Command::new(tasker_ctl_bin())
        .args([
            "generate",
            "types",
            "--template",
            "/nonexistent/template.yaml",
            "--language",
            "python",
        ])
        .output()
        .expect("Failed to execute tasker-ctl");

    assert!(!output.status.success());
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Failed to read template file"));
}

#[test]
fn test_generate_types_unsupported_language() {
    let output = Command::new(tasker_ctl_bin())
        .args([
            "generate",
            "types",
            "--template",
            fixture_path().to_str().unwrap(),
            "--language",
            "java",
        ])
        .output()
        .expect("Failed to execute tasker-ctl");

    assert!(!output.status.success());
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("unsupported language"));
}

// ── Output to file ──────────────────────────────────────────────────

#[test]
fn test_generate_types_output_to_file() {
    let dir = tempfile::tempdir().unwrap();
    let output_path = dir.path().join("generated.py");

    let output = Command::new(tasker_ctl_bin())
        .args([
            "generate",
            "types",
            "--template",
            fixture_path().to_str().unwrap(),
            "--language",
            "python",
            "--output",
            output_path.to_str().unwrap(),
        ])
        .output()
        .expect("Failed to execute tasker-ctl");

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    let contents = std::fs::read_to_string(&output_path).unwrap();
    assert!(contents.contains("class CodegenTestsValidateOrderResult(BaseModel):"));
    assert!(contents.contains("class CodegenTestsEnrichOrderResult(BaseModel):"));
}
