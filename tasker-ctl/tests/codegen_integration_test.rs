//! Integration tests for `tasker-ctl generate types` (TAS-280)
//!
//! Tests the full CLI pipeline: YAML parsing → schema extraction → code generation.
//! Uses the codegen_test_template.yaml fixture which covers flat types, nested objects,
//! arrays, optional fields, and steps without result_schema.

use std::path::{Path, PathBuf};
use std::process::Command;

/// Get the path to the compiled tasker-ctl binary.
fn tasker_ctl_bin() -> PathBuf {
    PathBuf::from(env!("CARGO_BIN_EXE_tasker-ctl"))
}

/// Path to the codegen test fixture.
fn fixture_path() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("../tests/fixtures/task_templates/codegen_test_template.yaml")
}

/// Run `tasker-ctl generate types` with given language and optional extra args.
fn generate_types(language: &str, extra_args: &[&str]) -> std::process::Output {
    let mut args = vec!["generate", "types", "--template"];
    let fixture = fixture_path();
    let fixture_str = fixture.to_str().unwrap();
    args.push(fixture_str);
    args.push("--language");
    args.push(language);
    args.extend_from_slice(extra_args);

    Command::new(tasker_ctl_bin())
        .args(&args)
        .output()
        .expect("Failed to execute tasker-ctl")
}

// ── Python ──────────────────────────────────────────────────────────

#[test]
fn test_generate_python_types() {
    let output = generate_types("python", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Header
    assert!(stdout.contains("Generated by tasker-ctl"));
    assert!(stdout.contains("from pydantic import BaseModel"));

    // Input type (from input_schema) — should appear before result types
    assert!(stdout.contains("class CodegenTestInputItems(BaseModel):"));
    assert!(stdout.contains("class CodegenTestInputShippingAddress(BaseModel):"));
    assert!(stdout.contains("class CodegenTestInput(BaseModel):"));

    // Input type field assertions
    assert!(stdout.contains("order_id: str"));
    assert!(stdout.contains("customer_email: str"));
    assert!(stdout.contains("items: list[CodegenTestInputItems]"));

    // Input type appears before result types
    let input_pos = stdout.find("class CodegenTestInput(BaseModel):").unwrap();
    let result_pos = stdout
        .find("class ValidateOrderResult(BaseModel):")
        .unwrap();
    assert!(
        input_pos < result_pos,
        "Input type should appear before result types"
    );

    // ValidateOrderResult
    assert!(stdout.contains("class ValidateOrderResult(BaseModel):"));
    assert!(stdout.contains("validated: bool"));
    assert!(stdout.contains("order_total: float"));
    assert!(stdout.contains("item_count: int"));
    assert!(stdout.contains("notes: Optional[str] = None"));

    // EnrichOrderResult with nested Metadata
    assert!(stdout.contains("class EnrichOrderResultMetadata(BaseModel):"));
    assert!(stdout.contains("class EnrichOrderResult(BaseModel):"));

    // GenerateReportResult with arrays
    assert!(stdout.contains("class GenerateReportResult(BaseModel):"));
    assert!(stdout.contains("line_items: list[str]"));

    // process_payment has no result_schema — should NOT generate types
    assert!(!stdout.contains("ProcessPayment"));
}

// ── Ruby ────────────────────────────────────────────────────────────

#[test]
fn test_generate_ruby_types() {
    let output = generate_types("ruby", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Input type (from input_schema)
    assert!(stdout.contains("class CodegenTestInput < Dry::Struct"));
    assert!(stdout.contains("class CodegenTestInputItems < Dry::Struct"));
    assert!(stdout.contains("class CodegenTestInputShippingAddress < Dry::Struct"));

    assert!(stdout.contains("class ValidateOrderResult < Dry::Struct"));
    assert!(stdout.contains("attribute :validated, Types::Strict::Bool"));
    assert!(stdout.contains("attribute :order_total, Types::Strict::Float"));
    assert!(stdout.contains("attribute :item_count, Types::Strict::Integer"));

    assert!(stdout.contains("class EnrichOrderResultMetadata < Dry::Struct"));
    assert!(stdout.contains("class EnrichOrderResult < Dry::Struct"));
    assert!(stdout.contains("class GenerateReportResult < Dry::Struct"));

    assert!(!stdout.contains("ProcessPayment"));
}

// ── TypeScript ──────────────────────────────────────────────────────

#[test]
fn test_generate_typescript_types() {
    let output = generate_types("typescript", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Input type (from input_schema)
    assert!(stdout.contains("export interface CodegenTestInput {"));
    assert!(stdout.contains("export interface CodegenTestInputItems {"));
    assert!(stdout.contains("export interface CodegenTestInputShippingAddress {"));

    assert!(stdout.contains("export interface ValidateOrderResult {"));
    assert!(stdout.contains("validated: boolean;"));
    assert!(stdout.contains("order_total: number;"));
    assert!(stdout.contains("item_count: number;"));
    assert!(stdout.contains("notes?: string;"));

    assert!(stdout.contains("export interface EnrichOrderResultMetadata {"));
    assert!(stdout.contains("export interface EnrichOrderResult {"));
    assert!(stdout.contains("export interface GenerateReportResult {"));

    assert!(!stdout.contains("ProcessPayment"));
}

// ── Rust ────────────────────────────────────────────────────────────

#[test]
fn test_generate_rust_types() {
    let output = generate_types("rust", &[]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Input type (from input_schema)
    assert!(stdout.contains("pub struct CodegenTestInput {"));
    assert!(stdout.contains("pub struct CodegenTestInputItems {"));
    assert!(stdout.contains("pub struct CodegenTestInputShippingAddress {"));

    assert!(stdout.contains("pub struct ValidateOrderResult {"));
    assert!(stdout.contains("pub validated: bool,"));
    assert!(stdout.contains("pub order_total: f64,"));
    assert!(stdout.contains("pub item_count: i64,"));
    assert!(stdout.contains("pub notes: Option<String>,"));
    assert!(stdout.contains("#[derive(Debug, Clone, Serialize, Deserialize)]"));

    assert!(stdout.contains("pub struct EnrichOrderResultMetadata {"));
    assert!(stdout.contains("pub struct EnrichOrderResult {"));
    assert!(stdout.contains("pub struct GenerateReportResult {"));

    assert!(!stdout.contains("ProcessPayment"));
}

// ── Step filter ─────────────────────────────────────────────────────

#[test]
fn test_generate_types_with_step_filter() {
    let output = generate_types("python", &["--step", "validate_order"]);
    let stdout = String::from_utf8_lossy(&output.stdout);

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    // Only validate_order types should appear
    assert!(stdout.contains("class ValidateOrderResult(BaseModel):"));

    // Input type should NOT appear when step filter is active
    assert!(!stdout.contains("CodegenTestInput"));

    // Other steps should NOT appear
    assert!(!stdout.contains("EnrichOrder"));
    assert!(!stdout.contains("GenerateReport"));
}

// ── Language aliases ────────────────────────────────────────────────

#[test]
fn test_generate_types_language_aliases() {
    for (alias, expected) in [
        ("py", "class ValidateOrderResult(BaseModel):"),
        ("rb", "class ValidateOrderResult < Dry::Struct"),
        ("ts", "export interface ValidateOrderResult {"),
        ("rs", "pub struct ValidateOrderResult {"),
    ] {
        let output = generate_types(alias, &["--step", "validate_order"]);
        let stdout = String::from_utf8_lossy(&output.stdout);
        assert!(
            output.status.success(),
            "alias '{}' failed: {}",
            alias,
            String::from_utf8_lossy(&output.stderr)
        );
        assert!(
            stdout.contains(expected),
            "alias '{}' output missing '{}' in:\n{}",
            alias,
            expected,
            stdout
        );
    }
}

// ── Error cases ─────────────────────────────────────────────────────

#[test]
fn test_generate_types_file_not_found() {
    let output = Command::new(tasker_ctl_bin())
        .args([
            "generate",
            "types",
            "--template",
            "/nonexistent/template.yaml",
            "--language",
            "python",
        ])
        .output()
        .expect("Failed to execute tasker-ctl");

    assert!(!output.status.success());
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Failed to read template file"));
}

#[test]
fn test_generate_types_unsupported_language() {
    let output = Command::new(tasker_ctl_bin())
        .args([
            "generate",
            "types",
            "--template",
            fixture_path().to_str().unwrap(),
            "--language",
            "java",
        ])
        .output()
        .expect("Failed to execute tasker-ctl");

    assert!(!output.status.success());
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("unsupported language"));
}

// ── Output to file ──────────────────────────────────────────────────

#[test]
fn test_generate_types_output_to_file() {
    let dir = tempfile::tempdir().unwrap();
    let output_path = dir.path().join("generated.py");

    let output = Command::new(tasker_ctl_bin())
        .args([
            "generate",
            "types",
            "--template",
            fixture_path().to_str().unwrap(),
            "--language",
            "python",
            "--output",
            output_path.to_str().unwrap(),
        ])
        .output()
        .expect("Failed to execute tasker-ctl");

    assert!(
        output.status.success(),
        "stderr: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    let contents = std::fs::read_to_string(&output_path).unwrap();
    assert!(contents.contains("class ValidateOrderResult(BaseModel):"));
    assert!(contents.contains("class EnrichOrderResult(BaseModel):"));
}
