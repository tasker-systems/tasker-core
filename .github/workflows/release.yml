name: Release

on:
  push:
    tags:
      - 'release-*'
      - 'v*'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no actual publishing)'
        required: true
        type: boolean
        default: true
      from_ref:
        description: 'Base ref for change detection (optional, defaults to last release tag)'
        required: false
        type: string

# =============================================================================
# FORCED DRY-RUN MODE
# =============================================================================
# Set to 'false' when ready to enable real publishing.
# This overrides all jobs — even tag-triggered runs will only dry-run.
# =============================================================================
env:
  RELEASE_DRY_RUN: 'false'

concurrency:
  group: release
  cancel-in-progress: false

# =============================================================================
# Job DAG:
#
#   detect-and-read           (5 min)
#           |
#     pre-flight-check        (15 min) — fmt, clippy, cargo publish --dry-run
#           |
#     +-----+------------------+
#     |                        |
#  publish-crates          build-ffi-libraries  (3x matrix: amd64/arm64/macOS)
#  (20 min)                (45-60 min)
#     |                        |
#     +-----+------------------+
#           |
#     +----------+----------+----------+--------------------+
#     |          |          |          |                    |
#  publish-   publish-   publish-   publish-containers     |
#  ruby       python     typescript (4x matrix, amd64)    |
#  (10 min)   (10 min)   (15 min)   (30 min each)        |
#     |          |          |          |                    |
#     +----------+----------+----------+--------------------+
#           |
#     release-summary       — reports results, creates GitHub Release
# =============================================================================

jobs:
  # ============================================================================
  # Stage 1: Read committed versions and detect changes for publish gating
  # ============================================================================
  detect-and-read:
    name: Read Versions & Detect Changes
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      core_changed: ${{ steps.detect.outputs.CORE_CHANGED }}
      ffi_core_changed: ${{ steps.detect.outputs.FFI_CORE_CHANGED }}
      server_core_changed: ${{ steps.detect.outputs.SERVER_CORE_CHANGED }}
      ruby_changed: ${{ steps.detect.outputs.RUBY_CHANGED }}
      python_changed: ${{ steps.detect.outputs.PYTHON_CHANGED }}
      typescript_changed: ${{ steps.detect.outputs.TYPESCRIPT_CHANGED }}
      containers_changed: ${{ steps.detect.outputs.CONTAINERS_CHANGED }}
      core_version: ${{ steps.read.outputs.CORE_VERSION }}
      ruby_version: ${{ steps.read.outputs.RUBY_VERSION }}
      python_version: ${{ steps.read.outputs.PYTHON_VERSION }}
      typescript_version: ${{ steps.read.outputs.TYPESCRIPT_VERSION }}
      is_dry_run: ${{ steps.dry-run.outputs.is_dry_run }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Determine dry-run mode
        id: dry-run
        run: .github/scripts/release/determine-dry-run.sh
        env:
          RELEASE_DRY_RUN_OVERRIDE: ${{ env.RELEASE_DRY_RUN }}
          EVENT_NAME: ${{ github.event_name }}
          INPUT_DRY_RUN: ${{ inputs.dry_run }}

      - name: Read committed versions
        id: read
        run: ./scripts/release/read-versions.sh >> "$GITHUB_OUTPUT"

      - name: Detect changes for publish gating
        id: detect
        run: |
          EXTRA_ARGS=""
          if [[ -n "${{ inputs.from_ref }}" ]]; then
            EXTRA_ARGS="--from ${{ inputs.from_ref }}"
          fi
          # shellcheck disable=SC2086
          ./scripts/release/detect-changes.sh ${EXTRA_ARGS} >> "$GITHUB_OUTPUT"

      - name: Summary
        run: .github/scripts/release/detection-summary.sh
        env:
          CORE_CHANGED: ${{ steps.detect.outputs.CORE_CHANGED }}
          FFI_CORE_CHANGED: ${{ steps.detect.outputs.FFI_CORE_CHANGED }}
          RUBY_CHANGED: ${{ steps.detect.outputs.RUBY_CHANGED }}
          PYTHON_CHANGED: ${{ steps.detect.outputs.PYTHON_CHANGED }}
          TS_CHANGED: ${{ steps.detect.outputs.TYPESCRIPT_CHANGED }}
          CONTAINERS_CHANGED: ${{ steps.detect.outputs.CONTAINERS_CHANGED }}
          CORE_VERSION: ${{ steps.read.outputs.CORE_VERSION }}
          RUBY_VERSION: ${{ steps.read.outputs.RUBY_VERSION }}
          PYTHON_VERSION: ${{ steps.read.outputs.PYTHON_VERSION }}
          TS_VERSION: ${{ steps.read.outputs.TYPESCRIPT_VERSION }}
          IS_DRY_RUN: ${{ steps.dry-run.outputs.is_dry_run }}

  # ============================================================================
  # Stage 2: Pre-flight validation
  # ============================================================================
  pre-flight-check:
    name: Pre-flight Validation
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    needs: detect-and-read
    permissions:
      contents: read
    env:
      SQLX_OFFLINE: 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Setup Rust build cache
        uses: ./.github/actions/setup-rust-cache

      - name: Install protobuf compiler
        uses: ./.github/actions/install-protobuf

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Run clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Validate crate publishability
        run: .github/scripts/release/validate-publishability.sh

  # ============================================================================
  # Stage 2b: Build FFI Libraries (cross-architecture)
  # ============================================================================
  # Builds all 3 FFI libraries for 3 architectures (9 artifacts total).
  # Runs in parallel with publish-crates. Publish jobs download pre-built
  # artifacts instead of compiling from source.
  build-ffi-libraries:
    name: Build FFI Libraries
    needs: [detect-and-read, pre-flight-check]
    if: |
      always() && !cancelled() && !failure() &&
      (needs.detect-and-read.outputs.ffi_core_changed == 'true' ||
       needs.detect-and-read.outputs.ruby_changed == 'true' ||
       needs.detect-and-read.outputs.python_changed == 'true' ||
       needs.detect-and-read.outputs.typescript_changed == 'true')
    permissions:
      contents: read
    uses: ./.github/workflows/build-ffi-libraries.yml
    with:
      version: ${{ needs.detect-and-read.outputs.core_version }}

  # ============================================================================
  # Stage 3: Publish Rust crates
  # ============================================================================
  publish-crates:
    name: Publish Rust Crates
    runs-on: ubuntu-22.04
    timeout-minutes: 20
    needs: [detect-and-read, pre-flight-check]
    if: needs.detect-and-read.outputs.core_changed == 'true'
    permissions:
      contents: write
    env:
      SQLX_OFFLINE: 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Rust build cache
        uses: ./.github/actions/setup-rust-cache

      - name: Install protobuf compiler
        uses: ./.github/actions/install-protobuf

      - name: Publish crates
        run: .github/scripts/release/publish-component.sh
        env:
          PUBLISH_SCRIPT: ./scripts/release/publish-crates.sh
          VERSION: ${{ needs.detect-and-read.outputs.core_version }}
          IS_DRY_RUN: ${{ needs.detect-and-read.outputs.is_dry_run }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

      - name: Tag core release
        if: needs.detect-and-read.outputs.is_dry_run != 'true'
        run: .github/scripts/release/tag-component.sh
        env:
          COMPONENT: core
          VERSION: ${{ needs.detect-and-read.outputs.core_version }}

  # ============================================================================
  # Stage 4: Publish FFI bindings (in parallel)
  # ============================================================================

  publish-ruby:
    name: Publish Ruby Gem
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    needs: [detect-and-read, pre-flight-check, publish-crates, build-ffi-libraries]
    # Run if ruby or FFI core changed, even if publish-crates or build-ffi-libraries was skipped.
    # The gem ships source — users compile the native extension at install time.
    # build-ffi-libraries validates that the Rust code compiles for all architectures.
    if: |
      always() && !cancelled() && !failure() &&
      (needs.detect-and-read.outputs.ruby_changed == 'true' ||
       needs.detect-and-read.outputs.ffi_core_changed == 'true')
    permissions:
      contents: write
      id-token: write
    environment: rbgem
    steps:
      - name: Check if already published
        id: check-published
        run: |
          VERSION="${{ needs.detect-and-read.outputs.ruby_version }}"
          if curl -sf "https://rubygems.org/api/v1/versions/tasker-rb.json" | grep -q "\"number\":\"${VERSION}\""; then
            echo "tasker-rb ${VERSION} already exists on RubyGems — skipping build and publish"
            echo "already_published=true" >> "$GITHUB_OUTPUT"
          else
            echo "already_published=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout code
        if: steps.check-published.outputs.already_published != 'true'
        uses: actions/checkout@v6

      - name: Setup Ruby
        if: steps.check-published.outputs.already_published != 'true'
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.4'

      # No Rust compilation needed — gem ships source with spec.extensions.
      # build-ffi-libraries already validated the build for all architectures.
      - name: Build source gem
        if: steps.check-published.outputs.already_published != 'true'
        run: cd workers/ruby && gem build tasker-rb.gemspec

      - name: Configure RubyGems credentials (OIDC)
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run != 'true'
        uses: rubygems/configure-rubygems-credentials@v1.0.0

      - name: Publish gem
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run != 'true'
        run: gem push workers/ruby/tasker-rb-*.gem

      - name: Dry-run summary
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run == 'true'
        run: |
          echo "[dry-run] Would publish:"
          ls -la workers/ruby/tasker-rb-*.gem

      - name: Tag ruby release
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run != 'true'
        run: .github/scripts/release/tag-component.sh
        env:
          COMPONENT: ruby
          VERSION: ${{ needs.detect-and-read.outputs.ruby_version }}

  publish-python:
    name: Publish Python Package
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    needs: [detect-and-read, pre-flight-check, publish-crates, build-ffi-libraries]
    # Uploads pre-built wheels from build-ffi-libraries to PyPI.
    # No Rust compilation — all 3 architecture wheels are pre-built.
    if: |
      always() && !cancelled() && !failure() &&
      (needs.detect-and-read.outputs.python_changed == 'true' ||
       needs.detect-and-read.outputs.ffi_core_changed == 'true')
    permissions:
      contents: write
      id-token: write
    environment: pypi
    steps:
      - name: Check if already published
        id: check-published
        run: |
          VERSION="${{ needs.detect-and-read.outputs.python_version }}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/tasker-py/${VERSION}/json")
          if [[ "$STATUS" == "200" ]]; then
            echo "tasker-py ${VERSION} already exists on PyPI — skipping publish"
            echo "already_published=true" >> "$GITHUB_OUTPUT"
          else
            echo "already_published=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Download pre-built wheels
        if: steps.check-published.outputs.already_published != 'true'
        uses: actions/download-artifact@v6
        with:
          pattern: ffi-${{ needs.detect-and-read.outputs.core_version }}-*
          path: ffi-artifacts/
          merge-multiple: true

      - name: Collect wheels
        if: steps.check-published.outputs.already_published != 'true'
        id: collect
        run: |
          mkdir -p dist/
          find ffi-artifacts/ -path '*/python/*.whl' -exec cp {} dist/ \;
          echo "Wheels to publish:"
          ls -la dist/
          WHEEL_COUNT=$(find dist/ -name '*.whl' | wc -l)
          if [[ "$WHEEL_COUNT" -eq 0 ]]; then
            echo "::error::No wheel files found in downloaded artifacts"
            exit 1
          fi
          echo "Found ${WHEEL_COUNT} wheel(s) for upload"

      - name: Publish to PyPI
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run != 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/
          skip-existing: true

      - name: Dry-run summary
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run == 'true'
        run: |
          echo "[dry-run] Would publish the following wheels to PyPI:"
          ls -la dist/

      - name: Checkout code
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run != 'true'
        uses: actions/checkout@v6

      - name: Tag python release
        if: steps.check-published.outputs.already_published != 'true' && needs.detect-and-read.outputs.is_dry_run != 'true'
        run: .github/scripts/release/tag-component.sh
        env:
          COMPONENT: python
          VERSION: ${{ needs.detect-and-read.outputs.python_version }}

  publish-typescript:
    name: Publish TypeScript Package
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    needs: [detect-and-read, pre-flight-check, publish-crates, build-ffi-libraries]
    if: |
      always() && !cancelled() && !failure() &&
      (needs.detect-and-read.outputs.typescript_changed == 'true' ||
       needs.detect-and-read.outputs.ffi_core_changed == 'true')
    permissions:
      contents: write
      id-token: write
    environment: npm
    env:
      SQLX_OFFLINE: 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '24'

      - name: Publish package
        run: .github/scripts/release/publish-component.sh
        env:
          PUBLISH_SCRIPT: ./scripts/release/publish-typescript.sh
          VERSION: ${{ needs.detect-and-read.outputs.typescript_version }}
          IS_DRY_RUN: ${{ needs.detect-and-read.outputs.is_dry_run }}

      - name: Tag typescript release
        if: needs.detect-and-read.outputs.is_dry_run != 'true'
        run: .github/scripts/release/tag-component.sh
        env:
          COMPONENT: typescript
          VERSION: ${{ needs.detect-and-read.outputs.typescript_version }}

  # ============================================================================
  # Stage 4b: Publish Container Images to GHCR (parallel matrix, amd64)
  # ============================================================================
  # Each image builds in its own parallel job via matrix strategy.
  # amd64-only for now; add arm64 with native runners later (no QEMU).
  publish-containers:
    name: Publish ${{ matrix.image.name }}
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    needs: [detect-and-read, pre-flight-check]
    if: |
      always() && !cancelled() && !failure() &&
      (needs.detect-and-read.outputs.core_changed == 'true' ||
       needs.detect-and-read.outputs.containers_changed == 'true')
    permissions:
      contents: read
      packages: write
    env:
      SQLX_OFFLINE: 'true'
    strategy:
      fail-fast: false
      matrix:
        image:
          - name: tasker-orchestration
            dockerfile: docker/build/orchestration.prod.Dockerfile
          - name: tasker-worker-ruby
            dockerfile: docker/build/ruby-worker.prod.Dockerfile
          - name: tasker-worker-python
            dockerfile: docker/build/python-worker.prod.Dockerfile
          - name: tasker-worker-typescript
            dockerfile: docker/build/typescript-worker.prod.Dockerfile
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Free disk space
        uses: ./.github/actions/free-disk-space

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ matrix.image.name }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.detect-and-read.outputs.core_version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.detect-and-read.outputs.core_version }}
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.image.dockerfile }}
          push: ${{ needs.detect-and-read.outputs.is_dry_run != 'true' }}
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.image.name }}
          cache-to: type=gha,scope=${{ matrix.image.name }},mode=max

  # ============================================================================
  # Stage 5: Release Summary
  # ============================================================================
  release-summary:
    name: Release Summary
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    needs: [detect-and-read, publish-crates, build-ffi-libraries, publish-ruby, publish-python, publish-typescript, publish-containers]
    if: always()
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download FFI artifacts
        if: needs.build-ffi-libraries.result == 'success'
        uses: actions/download-artifact@v6
        with:
          pattern: ffi-${{ needs.detect-and-read.outputs.core_version }}-*
          path: ffi-artifacts/
          merge-multiple: false

      - name: Generate summary
        run: .github/scripts/release/generate-summary.sh
        env:
          IS_DRY_RUN: ${{ needs.detect-and-read.outputs.is_dry_run }}
          CRATES_RESULT: ${{ needs.publish-crates.result }}
          RUBY_RESULT: ${{ needs.publish-ruby.result }}
          PYTHON_RESULT: ${{ needs.publish-python.result }}
          TS_RESULT: ${{ needs.publish-typescript.result }}
          CONTAINERS_RESULT: ${{ needs.publish-containers.result }}
          FFI_RESULT: ${{ needs.build-ffi-libraries.result }}
          CORE_VERSION: ${{ needs.detect-and-read.outputs.core_version }}
          RUBY_VERSION: ${{ needs.detect-and-read.outputs.ruby_version }}
          PYTHON_VERSION: ${{ needs.detect-and-read.outputs.python_version }}
          TS_VERSION: ${{ needs.detect-and-read.outputs.typescript_version }}

      - name: Check for failures
        id: check-failures
        run: .github/scripts/release/check-failures.sh
        env:
          CRATES_RESULT: ${{ needs.publish-crates.result }}
          RUBY_RESULT: ${{ needs.publish-ruby.result }}
          PYTHON_RESULT: ${{ needs.publish-python.result }}
          TS_RESULT: ${{ needs.publish-typescript.result }}
          CONTAINERS_RESULT: ${{ needs.publish-containers.result }}
          FFI_RESULT: ${{ needs.build-ffi-libraries.result }}

      - name: Create GitHub Release
        if: |
          needs.detect-and-read.outputs.is_dry_run != 'true' &&
          steps.check-failures.outputs.has_failures != 'true'
        run: .github/scripts/release/create-github-release.sh
        env:
          GH_TOKEN: ${{ github.token }}
          CORE_VERSION: ${{ needs.detect-and-read.outputs.core_version }}
          CRATES_RESULT: ${{ needs.publish-crates.result }}
          RUBY_RESULT: ${{ needs.publish-ruby.result }}
          PYTHON_RESULT: ${{ needs.publish-python.result }}
          TS_RESULT: ${{ needs.publish-typescript.result }}
          CONTAINERS_RESULT: ${{ needs.publish-containers.result }}
          FFI_RESULT: ${{ needs.build-ffi-libraries.result }}
          RUBY_VERSION: ${{ needs.detect-and-read.outputs.ruby_version }}
          PYTHON_VERSION: ${{ needs.detect-and-read.outputs.python_version }}
          TS_VERSION: ${{ needs.detect-and-read.outputs.typescript_version }}

      - name: Attach FFI artifacts to release
        if: |
          needs.detect-and-read.outputs.is_dry_run != 'true' &&
          steps.check-failures.outputs.has_failures != 'true' &&
          needs.build-ffi-libraries.result == 'success'
        run: |
          VERSION="${{ needs.detect-and-read.outputs.core_version }}"
          TAG="v${VERSION}"
          if [[ -d "ffi-artifacts" ]]; then
            echo "Attaching FFI artifacts to release ${TAG}..."
            find ffi-artifacts/ -type f | while read -r artifact; do
              echo "  Uploading: ${artifact}"
              gh release upload "${TAG}" "${artifact}" --clobber || true
            done
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Log dry-run release (would have created)
        if: |
          needs.detect-and-read.outputs.is_dry_run == 'true' &&
          steps.check-failures.outputs.has_failures != 'true'
        run: .github/scripts/release/log-dry-run-release.sh
        env:
          CORE_VERSION: ${{ needs.detect-and-read.outputs.core_version }}
