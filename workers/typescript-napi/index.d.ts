/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Configuration for bootstrapping the worker.
 * In koffi, this was a JSON string. In napi-rs, it's a native JS object.
 */
export interface BootstrapConfig {
  /** Worker namespace (e.g., "default", "ecommerce_ts") */
  namespace?: string
  /** Path to worker configuration file */
  configPath?: string
}
/**
 * Result of bootstrapping the worker.
 * In koffi, this was a JSON string like {"success": true, "worker_id": "..."}.
 * In napi-rs, it's a native JS object with typed fields.
 */
export interface BootstrapResult {
  success: boolean
  status: string
  message: string
  workerId?: string
}
/** Worker status information. */
export interface WorkerStatus {
  success: boolean
  running: boolean
  workerId?: string
  status?: string
  environment?: string
}
/**
 * A step event dispatched to the TypeScript handler.
 * In koffi, this was a JSON string requiring manual parsing.
 * In napi-rs, TypeScript receives a typed object directly.
 */
export interface NapiStepEvent {
  eventId: string
  taskUuid: string
  stepUuid: string
  correlationId: string
  traceId?: string
  spanId?: string
  taskCorrelationId: string
  parentCorrelationId?: string
  task: NapiTaskInfo
  workflowStep: NapiWorkflowStep
  stepDefinition: NapiStepDefinition
  dependencyResults: Record<string, NapiDependencyResult>
}
export interface NapiTaskInfo {
  taskUuid: string
  namedTaskUuid: string
  name: string
  namespace: string
  version: string
  /** Native JS object — no JSON parsing needed! */
  context?: any
  correlationId: string
  parentCorrelationId?: string
  complete: boolean
  priority: number
  initiator?: string
  sourceSystem?: string
  reason?: string
  tags?: any
  identityHash: string
  createdAt: string
  updatedAt: string
  requestedAt: string
}
export interface NapiWorkflowStep {
  workflowStepUuid: string
  taskUuid: string
  namedStepUuid: string
  name: string
  templateStepName: string
  retryable: boolean
  maxAttempts: number
  attempts: number
  inProcess: boolean
  processed: boolean
  inputs?: any
  results?: any
  backoffRequestSeconds?: number
  processedAt?: string
  lastAttemptedAt?: string
  createdAt: string
  updatedAt: string
  checkpoint?: any
}
export interface NapiStepDefinition {
  name: string
  description?: string
  handlerCallable: string
  handlerMethod?: string
  handlerResolver?: string
  handlerInitialization: any
  systemDependency?: string
  dependencies: Array<string>
  timeoutSeconds?: number
  retryRetryable: boolean
  retryMaxAttempts: number
  retryBackoff: string
  retryBackoffBaseMs?: number
  retryMaxBackoffMs?: number
}
export interface NapiDependencyResult {
  stepUuid: string
  success: boolean
  result: any
  status: string
  errorMessage?: string
  errorType?: string
  errorRetryable?: boolean
}
/**
 * Result of completing a step event.
 * In koffi, the handler returned a JSON string with these fields.
 * In napi-rs, TypeScript passes a native object.
 */
export interface NapiStepResult {
  stepUuid: string
  success: boolean
  result: any
  status: string
  errorMessage?: string
  errorType?: string
  errorRetryable?: boolean
  errorStatusCode?: number
}
/**
 * Bootstrap the worker system.
 *
 * Unlike the koffi version, this accepts a native JS object (not JSON string)
 * and returns a native JS object (not JSON string). Errors throw exceptions.
 */
export declare function bootstrapWorker(config?: BootstrapConfig | undefined | null): BootstrapResult
/** Get worker status. */
export declare function getWorkerStatus(): WorkerStatus
/** Stop the worker system. */
export declare function stopWorker(): WorkerStatus
/**
 * Poll for a step event to dispatch.
 *
 * Returns a typed NapiStepEvent object or null. In koffi, this returned
 * a JSON string or null. The napi-rs version eliminates JSON parsing entirely.
 */
export declare function pollStepEvents(): NapiStepEvent | null
/**
 * Complete a step event with the handler's result.
 *
 * In koffi: `complete_step_event(event_id: string, result_json: string) -> string`
 * In napi-rs: `completeStepEvent(eventId: string, result: NapiStepResult) -> boolean`
 *
 * No JSON serialization, no manual memory management, typed result object.
 */
export declare function completeStepEvent(eventId: string, result: NapiStepResult): boolean
/**
 * Task creation request — THE critical type.
 *
 * In koffi, this was serialized to JSON, passed as a C string, and parsed
 * with `serde_json::Deserializer::from_str` to tolerate trailing bytes.
 * That workaround STILL fails (TAS-283).
 *
 * In napi-rs, this is a native JS object. No serialization. No trailing bytes.
 */
export interface NapiTaskRequest {
  name: string
  namespace: string
  version: string
  /** Native JS object — napi-rs handles this via serde-json feature */
  context: any
  initiator: string
  sourceSystem: string
  reason: string
  tags?: Array<string>
  priority?: number
  correlationId?: string
  parentCorrelationId?: string
  idempotencyKey?: string
}
/**
 * Client operation result.
 *
 * In koffi, all client operations returned JSON: {"success": true, "data": {...}}
 * In napi-rs, success returns the data directly, failure throws an exception.
 * We keep the envelope for now to match the existing TypeScript API surface.
 */
export interface NapiClientResult {
  success: boolean
  /** The response data as a JS object (task info, step list, etc.) */
  data?: any
  error?: string
  recoverable?: boolean
}
/** Parameters for listing tasks. */
export interface NapiListTasksParams {
  limit?: number
  offset?: number
  namespace?: string
  status?: string
}
/**
 * Create a task — **THE definitive TAS-283 test**.
 *
 * In koffi: `client_create_task(json_string) -> json_string`
 *   → Fails with "trailing input" due to C string marshalling
 *
 * In napi-rs: `clientCreateTask(request: NapiTaskRequest) -> NapiClientResult`
 *   → Native object, no serialization, no trailing bytes
 */
export declare function clientCreateTask(request: NapiTaskRequest): NapiClientResult
/** Get a task by UUID. */
export declare function clientGetTask(taskUuid: string): NapiClientResult
/** List tasks with optional filters. */
export declare function clientListTasks(params: NapiListTasksParams): NapiClientResult
/** Cancel a task by UUID. */
export declare function clientCancelTask(taskUuid: string): NapiClientResult
/** List steps for a task. */
export declare function clientListTaskSteps(taskUuid: string): NapiClientResult
/** Health check against the orchestration API. */
export declare function clientHealthCheck(): NapiClientResult
/**
 * Returns the version of the tasker-ts-napi package.
 *
 * This is the simplest possible FFI function — no state, no serialization.
 * If this fails, napi-rs itself isn't working.
 */
export declare function getVersion(): string
/** Returns the Rust library version for debugging. */
export declare function getRustVersion(): string
/** Simple health check to verify the FFI layer is functional. */
export declare function healthCheck(): boolean
