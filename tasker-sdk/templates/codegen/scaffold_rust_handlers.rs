{# Scaffold: Rust plain function handlers (Pattern B) -#}
//! Generated by tasker-ctl generate scaffold. Do not edit.
//!
//! Plain function handlers for this workflow.
//! Each function receives task context and upstream dependency results,
//! deserializes typed models, and returns a JSON-serializable result.
//!
//! This follows Pattern B (plain functions + registry bridge) â€” the pattern
//! for application developers building standalone projects that depend on
//! tasker via Cargo.toml. See `handler_registry.rs` for the bridge that
//! wraps these functions as `StepHandler` trait objects.

use serde_json::Value;
use std::collections::HashMap;
{% if !import_types.is_empty() %}
use super::models::{
{%- for t in import_types %}
    {{ t }},
{%- endfor %}
};
{%- endif %}

/// Deserialize a typed result from the dependency results map.
fn get_dependency<T: serde::de::DeserializeOwned>(
    dependency_results: &HashMap<String, Value>,
    step_name: &str,
) -> Result<T, String> {
    dependency_results
        .get(step_name)
        .ok_or_else(|| format!("Missing dependency result: {}", step_name))
        .and_then(|v| {
            serde_json::from_value(v.clone())
                .map_err(|e| format!("Failed to deserialize '{}' result: {}", step_name, e))
        })
}
{% for handler in handlers %}

{% if handler.description.is_some() -%}
/// {{ handler.description.as_deref().unwrap_or_default() }}
{% endif -%}
pub fn {{ handler.snake_name() }}({% if handler.has_dependencies() %}_context{% else %}context{% endif %}: &Value, {% if handler.has_dependencies() %}deps{% else %}_deps{% endif %}: &HashMap<String, Value>) -> Result<Value, String> {
{%- for dep in handler.dependencies %}
{%- match dep.result_type.as_ref() %}
{%- when Some with (type_name) %}
    let _{{ dep.snake_param() }}: {{ type_name }} = get_dependency(deps, "{{ dep.step_name }}")?;
{%- when None %}
    // Dependency: {{ dep.step_name }} (untyped)
{%- endmatch %}
{%- endfor %}

    // TODO: implement handler logic
{%- match handler.result_type_name() %}
{%- when Some with (type_name) %}
{%- match type_map.get(type_name.as_str()) %}
{%- when Some with (td) %}
    let result = {{ type_name }} {
{%- for field in td.fields %}
        {{ field.snake_name() }}: {{ field.field_type.rust_stub_value() }},
{%- endfor %}
    };
    serde_json::to_value(result).map_err(|e| format!("Failed to serialize result: {}", e))
{%- when None %}
    serde_json::to_value(serde_json::json!({})).map_err(|e| format!("Failed to serialize result: {}", e))
{%- endmatch %}
{%- when None %}
    serde_json::to_value(serde_json::json!({})).map_err(|e| format!("Failed to serialize result: {}", e))
{%- endmatch %}
}
{%- endfor %}
