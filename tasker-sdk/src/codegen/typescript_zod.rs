//! TypeScript Zod schema code generation.

use askama::Template;

use super::schema::TypeDef;
use super::CodegenError;

#[derive(Template, Debug)]
#[template(path = "codegen/typescript_schemas.ts")]
struct TypeScriptZodTemplate<'a> {
    types: &'a [TypeDef],
}

/// Render TypeScript Zod schemas from type definitions.
pub fn render(types: &[TypeDef]) -> Result<String, CodegenError> {
    let template = TypeScriptZodTemplate { types };
    template
        .render()
        .map_err(|e| CodegenError::Rendering(e.to_string()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::schema::{FieldDef, FieldType};

    #[test]
    fn test_zod_flat_types() {
        let types = vec![TypeDef {
            name: "ValidateOrderResult".to_string(),
            description: Some("Order validation".to_string()),
            fields: vec![
                FieldDef {
                    name: "validated".to_string(),
                    field_type: FieldType::Boolean,
                    required: true,
                    description: None,
                },
                FieldDef {
                    name: "order_total".to_string(),
                    field_type: FieldType::Number,
                    required: true,
                    description: None,
                },
                FieldDef {
                    name: "notes".to_string(),
                    field_type: FieldType::String,
                    required: false,
                    description: None,
                },
            ],
        }];

        let output = render(&types).unwrap();
        assert!(output.contains("import { z } from 'zod';"));
        assert!(output.contains("export const ValidateOrderResultSchema = z.object({"));
        assert!(output.contains("validated: z.boolean(),"));
        assert!(output.contains("order_total: z.number(),"));
        assert!(output.contains("notes: z.string().optional(),"));
        assert!(output.contains("}).passthrough();"));
        assert!(output.contains(
            "export type ValidateOrderResult = z.infer<typeof ValidateOrderResultSchema>;"
        ));
    }

    #[test]
    fn test_zod_string_enum() {
        let types = vec![TypeDef {
            name: "StatusResult".to_string(),
            description: None,
            fields: vec![FieldDef {
                name: "status".to_string(),
                field_type: FieldType::StringEnum(vec![
                    "active".to_string(),
                    "inactive".to_string(),
                ]),
                required: true,
                description: None,
            }],
        }];

        let output = render(&types).unwrap();
        assert!(output.contains("status: z.enum(['active', 'inactive']),"));
    }

    #[test]
    fn test_zod_nested_type() {
        let types = vec![
            TypeDef {
                name: "ResultMetadata".to_string(),
                description: None,
                fields: vec![FieldDef {
                    name: "source".to_string(),
                    field_type: FieldType::String,
                    required: true,
                    description: None,
                }],
            },
            TypeDef {
                name: "ProcessResult".to_string(),
                description: None,
                fields: vec![FieldDef {
                    name: "metadata".to_string(),
                    field_type: FieldType::Nested("ResultMetadata".to_string()),
                    required: true,
                    description: None,
                }],
            },
        ];

        let output = render(&types).unwrap();
        assert!(output.contains("export const ResultMetadataSchema = z.object({"));
        assert!(output.contains("metadata: ResultMetadataSchema,"));
    }

    #[test]
    fn test_zod_array_types() {
        let types = vec![TypeDef {
            name: "ListResult".to_string(),
            description: None,
            fields: vec![FieldDef {
                name: "items".to_string(),
                field_type: FieldType::Array(Box::new(FieldType::String)),
                required: true,
                description: None,
            }],
        }];

        let output = render(&types).unwrap();
        assert!(output.contains("items: z.array(z.string()),"));
    }

    #[test]
    fn test_zod_empty_types() {
        let output = render(&[]).unwrap();
        assert!(output.contains("Generated by tasker-ctl"));
        assert!(!output.contains("export const"));
    }
}
