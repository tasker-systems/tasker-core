{# Scaffold: Rust handlers with type imports and typed return values -#}
//! Generated by tasker-ctl generate scaffold. Handlers use generated types.

use anyhow::Result;
use async_trait::async_trait;
{% if needs_any -%}
use serde_json::{json, Value};
{%- else -%}
use serde_json::json;
{%- endif %}
{% if needs_hashmap -%}
use std::collections::HashMap;
{%- endif %}
use tasker_shared::messaging::execution_types::StepExecutionResult;
use tasker_shared::types::base::TaskSequenceStep;
use tasker_worker_rust::step_handlers::{success_result, RustStepHandler, StepHandlerConfig};
{% if !import_types.is_empty() -%}
use super::models::{%raw%}{{%endraw%}{% for t in import_types %}{{ t }}{% if !loop.last %}, {% endif %}{% endfor %}{%raw%}}{%endraw%};
{%- endif %}
{% for handler in handlers %}

#[derive(Debug)]
pub struct {{ handler.pascal_name() }} {
    _config: StepHandlerConfig,
}

#[async_trait]
impl RustStepHandler for {{ handler.pascal_name() }} {
    fn name(&self) -> &'static str {
        "{{ handler.callable }}"
    }

    fn new(config: StepHandlerConfig) -> Self {
        Self { _config: config }
    }

    async fn call(&self, step_data: &TaskSequenceStep) -> Result<StepExecutionResult> {
        let step_uuid = step_data.workflow_step.workflow_step_uuid;
{%- for dep in handler.dependencies %}
        // Dependency: {{ dep.step_name }} â€” {{ dep.type_comment() }}
{%- endfor %}
        // TODO: implement handler logic
{%- match handler.result_type_name() %}
{%- when Some with (type_name) %}
{%- match type_map.get(type_name.as_str()) %}
{%- when Some with (td) %}
        let result = {{ type_name }} {
{%- for field in td.fields %}
            {{ field.snake_name() }}: {{ field.field_type.rust_stub_value() }},
{%- endfor %}
        };
        Ok(success_result(step_uuid, serde_json::to_value(result)?))
{%- when None %}
        Ok(success_result(step_uuid, json!({})))
{%- endmatch %}
{%- when None %}
        Ok(success_result(step_uuid, json!({})))
{%- endmatch %}
    }
}
{%- endfor %}
