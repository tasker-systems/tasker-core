{# Scaffold: Python handlers with type imports and typed return values -#}
"""Generated by tasker-ctl generate scaffold. Handlers import generated types."""
from tasker_core.step_handler.functional import step_handler, depends_on
{% if !import_types.is_empty() -%}
from .{{ types_module_name }} import {% for t in import_types %}{{ t }}{% if !loop.last %}, {% endif %}{% endfor %}

{% endif -%}
{% for handler in handlers %}

{% if handler.has_dependencies() -%}
@step_handler("{{ handler.callable }}")
{%- for dep in handler.dependencies %}
@depends_on({{ dep.snake_param() }}="{{ dep.step_name }}")
{%- endfor %}
def {{ handler.snake_name() }}(
    {%- for dep in handler.dependencies %}{{ dep.snake_param() }}, {% endfor %}context){% if handler.result_type_name().is_some() %} -> {{ handler.result_type_name().unwrap() }}{% endif %}:
{%- else -%}
@step_handler("{{ handler.callable }}")
def {{ handler.snake_name() }}(context){% if handler.result_type_name().is_some() %} -> {{ handler.result_type_name().unwrap() }}{% endif %}:
{%- endif %}
{% if handler.description.is_some() %}    """{{ handler.description.as_deref().unwrap_or_default() }}"""{% endif %}
{%- for dep in handler.dependencies %}
    # {{ dep.snake_param() }}: {{ dep.type_comment() }}
{%- endfor %}
    # TODO: implement handler logic
{%- match handler.result_type_name() %}
{%- when Some with (type_name) %}
{%- match type_map.get(type_name.as_str()) %}
{%- when Some with (td) %}
    return {{ type_name }}(
{%- for field in td.fields %}
        {{ field.name }}={{ field.field_type.python_stub_value() }},
{%- endfor %}
    )
{%- when None %}
    return {}
{%- endmatch %}
{%- when None %}
    return {}
{%- endmatch %}
{%- endfor %}
