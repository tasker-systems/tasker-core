{# TAS-280: Rust handler scaffold generation from task template -#}
//! Generated by tasker-ctl generate handler. Customize to implement your logic.

use anyhow::Result;
use async_trait::async_trait;
use serde_json::json;
use tasker_shared::messaging::execution_types::StepExecutionResult;
use tasker_shared::types::base::TaskSequenceStep;
use tasker_worker_rust::step_handlers::{success_result, RustStepHandler, StepHandlerConfig};
{% for handler in handlers %}

#[derive(Debug)]
pub struct {{ handler.pascal_name() }} {
    _config: StepHandlerConfig,
}

#[async_trait]
impl RustStepHandler for {{ handler.pascal_name() }} {
    fn name(&self) -> &'static str {
        "{{ handler.callable }}"
    }

    fn new(config: StepHandlerConfig) -> Self {
        Self { _config: config }
    }

    async fn call(&self, step_data: &TaskSequenceStep) -> Result<StepExecutionResult> {
        let step_uuid = step_data.workflow_step.workflow_step_uuid;
{%- for dep in handler.dependencies %}
        // Dependency: {{ dep.step_name }} â€” {{ dep.type_comment() }}
{%- endfor %}
        // TODO: implement handler logic
{%- if !handler.stub_fields.is_empty() %}
        Ok(success_result(step_uuid, json!({
{%- for field in handler.stub_fields %}
            "{{ field.name }}": {{ field.json_value() }}{% if !loop.last %},{% endif %}
{%- endfor %}
        })))
{%- else %}
        Ok(success_result(step_uuid, json!({})))
{%- endif %}
    }
}
{%- endfor %}
