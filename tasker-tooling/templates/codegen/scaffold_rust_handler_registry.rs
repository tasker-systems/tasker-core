{# Scaffold: Rust handler registry bridging plain functions to StepHandler trait -#}
//! Generated by tasker-ctl generate scaffold. Do not edit.
//!
//! Handler registry for the {{ namespace }} namespace.
//!
//! This module bridges the plain function handlers in `handlers.rs` to the
//! `StepHandler` trait required by the tasker-worker dispatch system. Each
//! function is wrapped in a `FunctionHandler` that extracts context and
//! dependency results from the `TaskSequenceStep` and calls the underlying
//! function.

use async_trait::async_trait;
use serde_json::Value;
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::Instant;

use tasker_shared::messaging::StepExecutionResult;
use tasker_shared::types::base::TaskSequenceStep;
use tasker_shared::TaskerResult;
use tasker_worker::worker::handlers::{StepHandler, StepHandlerRegistry};

use super::handlers;

/// Function signature for plain handler functions.
type HandlerFn =
    Box<dyn Fn(&Value, &HashMap<String, Value>) -> Result<Value, String> + Send + Sync>;

struct FunctionHandler {
    handler_name: String,
    handler_fn: HandlerFn,
}

impl FunctionHandler {
    fn new(name: impl Into<String>, f: HandlerFn) -> Self {
        Self {
            handler_name: name.into(),
            handler_fn: f,
        }
    }
}

#[async_trait]
impl StepHandler for FunctionHandler {
    async fn call(&self, step: &TaskSequenceStep) -> TaskerResult<StepExecutionResult> {
        let start = Instant::now();

        let context = step
            .task
            .task
            .context
            .clone()
            .unwrap_or_else(|| Value::Object(Default::default()));

        let dep_results: HashMap<String, Value> = step
            .dependency_results
            .iter()
            .map(|(name, result)| (name.clone(), result.result.clone()))
            .collect();

        let elapsed_ms = start.elapsed().as_millis() as i64;

        match (self.handler_fn)(&context, &dep_results) {
            Ok(result) => Ok(StepExecutionResult::success(
                step.workflow_step.workflow_step_uuid,
                result,
                elapsed_ms,
                None,
            )),
            Err(err) => Ok(StepExecutionResult::failure(
                step.workflow_step.workflow_step_uuid,
                err,
                None,
                None,
                false,
                elapsed_ms,
                None,
            )),
        }
    }

    fn name(&self) -> &str {
        &self.handler_name
    }
}

/// Handler registry for the {{ namespace }} namespace.
pub struct {{ registry_name }} {
    handlers: RwLock<HashMap<String, Arc<dyn StepHandler>>>,
}

impl {{ registry_name }} {
    /// Create a new registry with all handlers registered.
    pub fn new() -> Self {
        let registry = Self {
            handlers: RwLock::new(HashMap::new()),
        };
        registry.register_all();
        registry
    }

    /// Number of registered handlers.
    pub fn handler_count(&self) -> usize {
        self.handlers.read().expect("registry lock poisoned").len()
    }

    fn register_fn(&self, name: &str, f: HandlerFn) {
        let handler = Arc::new(FunctionHandler::new(name, f));
        self.handlers
            .write()
            .expect("registry lock poisoned")
            .insert(name.to_string(), handler);
    }

    /// Register all handlers for this workflow.
    fn register_all(&self) {
{%- for handler in handlers %}
        self.register_fn(
            "{{ handler.callable }}",
            Box::new(|ctx, deps| handlers::{{ handler.snake_name() }}(ctx, deps)),
        );
{%- endfor %}
    }
}

impl Default for {{ registry_name }} {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl StepHandlerRegistry for {{ registry_name }} {
    async fn get(&self, step: &TaskSequenceStep) -> Option<Arc<dyn StepHandler>> {
        let handlers = self.handlers.read().expect("registry lock poisoned");
        handlers
            .get(&step.step_definition.handler.callable)
            .cloned()
    }

    fn register(&self, name: &str, handler: Arc<dyn StepHandler>) {
        self.handlers
            .write()
            .expect("registry lock poisoned")
            .insert(name.to_string(), handler);
    }

    fn handler_available(&self, name: &str) -> bool {
        self.handlers
            .read()
            .expect("registry lock poisoned")
            .contains_key(name)
    }

    fn registered_handlers(&self) -> Vec<String> {
        self.handlers
            .read()
            .expect("registry lock poisoned")
            .keys()
            .cloned()
            .collect()
    }
}
